<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Luiz Irber" />
  <meta name="author" content="C. Titus Brown" />
  <meta name="dcterms.date" content="2020-10-04" />
  <meta name="keywords" content="k-mers, MinHash" />
  <title>Lightweight compositional analysis of metagenomes with sourmash gather</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!--
  Manubot generated metadata rendered from header-includes-template.html.
  Suggest improvements at https://github.com/manubot/manubot/blob/master/manubot/process/header-includes-template.html
  -->
  <meta name="dc.format" content="text/html" />
  <meta name="dc.title" content="Lightweight compositional analysis of metagenomes with sourmash gather" />
  <meta name="citation_title" content="Lightweight compositional analysis of metagenomes with sourmash gather" />
  <meta property="og:title" content="Lightweight compositional analysis of metagenomes with sourmash gather" />
  <meta property="twitter:title" content="Lightweight compositional analysis of metagenomes with sourmash gather" />
  <meta name="dc.date" content="2020-10-04" />
  <meta name="citation_publication_date" content="2020-10-04" />
  <meta name="dc.language" content="en-US" />
  <meta name="citation_language" content="en-US" />
  <meta name="dc.relation.ispartof" content="Manubot" />
  <meta name="dc.publisher" content="Manubot" />
  <meta name="citation_journal_title" content="Manubot" />
  <meta name="citation_technical_report_institution" content="Manubot" />
  <meta name="citation_author" content="Luiz Irber" />
  <meta name="citation_author_institution" content="Graduate Group in Computer Science, UC Davis" />
  <meta name="citation_author_institution" content="Department of Population Health and Reproduction, UC Davis" />
  <meta name="citation_author_orcid" content="0000-0003-4371-9659" />
  <meta name="twitter:creator" content="@luizirber" />
  <meta name="citation_author" content="C. Titus Brown" />
  <meta name="citation_author_institution" content="Department of Population Health and Reproduction, UC Davis" />
  <meta name="citation_author_orcid" content="0000-0001-6001-2677" />
  <link rel="canonical" href="https://dib-lab.github.io/2020-paper-sourmash-gather/" />
  <meta property="og:url" content="https://dib-lab.github.io/2020-paper-sourmash-gather/" />
  <meta property="twitter:url" content="https://dib-lab.github.io/2020-paper-sourmash-gather/" />
  <meta name="citation_fulltext_html_url" content="https://dib-lab.github.io/2020-paper-sourmash-gather/" />
  <meta name="citation_pdf_url" content="https://dib-lab.github.io/2020-paper-sourmash-gather/manuscript.pdf" />
  <link rel="alternate" type="application/pdf" href="https://dib-lab.github.io/2020-paper-sourmash-gather/manuscript.pdf" />
  <link rel="alternate" type="text/html" href="https://dib-lab.github.io/2020-paper-sourmash-gather/v/2900f681ba8e15d7f55fcd6e8783d6f79e4ce10d/" />
  <meta name="manubot_html_url_versioned" content="https://dib-lab.github.io/2020-paper-sourmash-gather/v/2900f681ba8e15d7f55fcd6e8783d6f79e4ce10d/" />
  <meta name="manubot_pdf_url_versioned" content="https://dib-lab.github.io/2020-paper-sourmash-gather/v/2900f681ba8e15d7f55fcd6e8783d6f79e4ce10d/manuscript.pdf" />
  <meta property="og:type" content="article" />
  <meta property="twitter:card" content="summary_large_image" />
  <link rel="icon" type="image/png" sizes="192x192" href="https://manubot.org/favicon-192x192.png" />
  <link rel="mask-icon" href="https://manubot.org/safari-pinned-tab.svg" color="#ad1457" />
  <meta name="theme-color" content="#ad1457" />
  <!-- end Manubot generated metadata -->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lightweight compositional analysis of metagenomes with sourmash gather</h1>
</header>
<p><small><em>
This manuscript
(<a href="https://dib-lab.github.io/2020-paper-sourmash-gather/v/2900f681ba8e15d7f55fcd6e8783d6f79e4ce10d/">permalink</a>)
was automatically generated
from <a href="https://github.com/dib-lab/2020-paper-sourmash-gather/tree/2900f681ba8e15d7f55fcd6e8783d6f79e4ce10d">dib-lab/2020-paper-sourmash-gather@2900f68</a>
on October 4, 2020.
</em></small></p>
<h2 id="authors">Authors</h2>
<ul>
<li><p><strong>Luiz Irber</strong><br>
<img src="images/orcid.svg" class="inline_icon" alt="ORCID icon" />
<a href="https://orcid.org/0000-0003-4371-9659">0000-0003-4371-9659</a>
· <img src="images/github.svg" class="inline_icon" alt="GitHub icon" />
<a href="https://github.com/luizirber">luizirber</a>
· <img src="images/twitter.svg" class="inline_icon" alt="Twitter icon" />
<a href="https://twitter.com/luizirber">luizirber</a><br>
<small>
Graduate Group in Computer Science, UC Davis; Department of Population Health and Reproduction, UC Davis
· Funded by Grant XXXXXXXX
</small></p></li>
<li><p><strong>C. Titus Brown</strong><br>
<img src="images/orcid.svg" class="inline_icon" alt="ORCID icon" />
<a href="https://orcid.org/0000-0001-6001-2677">0000-0001-6001-2677</a>
· <img src="images/github.svg" class="inline_icon" alt="GitHub icon" />
<a href="https://github.com/ctb">ctb</a><br>
<small>
Department of Population Health and Reproduction, UC Davis
</small></p></li>
</ul>
<h2 class="page_break_before" id="abstract">Abstract</h2>
<p>Here we describe an extension of MinHash that permits accurate compositional analysis of metagenomes with low memory and disk requirements.</p>
<h1 id="introduction">Introduction</h1>
<p>Compositional data analysis is the study of the parts of a whole using relative abundances <span class="citation" data-cites="aitchison_statistical_1982">[<span class="citeproc-not-found" data-reference-id="aitchison_statistical_1982"><strong>???</strong></span>]</span>.
This is a general problem with applications across many scientific fields <span class="citation" data-cites="aitchison_compositional_2005">[<span class="citeproc-not-found" data-reference-id="aitchison_compositional_2005"><strong>???</strong></span>]</span>,
and examples in biology include RNA-Seq <span class="citation" data-cites="quinn_field_2019-1">[<span class="citeproc-not-found" data-reference-id="quinn_field_2019-1"><strong>???</strong></span>]</span>,
metatranscriptomics <span class="citation" data-cites="macklaim_rna-seq_2018">[<span class="citeproc-not-found" data-reference-id="macklaim_rna-seq_2018"><strong>???</strong></span>]</span>,
microbiome and metagenomics <span class="citation" data-cites="li_microbiome_2015">[<span class="citeproc-not-found" data-reference-id="li_microbiome_2015"><strong>???</strong></span>]</span>.
Taxonomic profiling is a particular instance of this general problem
with the goal of finding the identity and relative abundance of microbial community elements
at a specific taxonomic rank (species, genus, family),
especially in metagenomic samples <span class="citation" data-cites="sczyrba_critical_2017">[<span class="citeproc-not-found" data-reference-id="sczyrba_critical_2017"><strong>???</strong></span>]</span>.</p>
<p>Existing taxonomic profilers use different methods to solve this problem,
including aligning sequences to a reference database <span class="citation" data-cites="huson_megan_2016">[<span class="citeproc-not-found" data-reference-id="huson_megan_2016"><strong>???</strong></span>]</span>,
using marker genes derived from known organisms from reference databases <span class="citation" data-cites="segata_metagenomic_2012">[<span class="citeproc-not-found" data-reference-id="segata_metagenomic_2012"><strong>???</strong></span>]</span>
or coupled with unknown organisms clustered from metagenomes <span class="citation" data-cites="milanese_microbial_2019">[<span class="citeproc-not-found" data-reference-id="milanese_microbial_2019"><strong>???</strong></span>]</span>,
and exact <span class="math inline">\(k\)</span>-mer matching using fixed <span class="math inline">\(k\)</span> and lowest common ancestor (LCA) for resolving
<span class="math inline">\(k\)</span>-mer assignments matching multiple taxons from a reference database
<span class="citation" data-cites="wood_kraken:_2014">[<span class="citeproc-not-found" data-reference-id="wood_kraken:_2014"><strong>???</strong></span>]</span> or variable <span class="math inline">\(k\)</span> and assigning multiple taxons per sequence,
with an option to reduce it further to the LCA <span class="citation" data-cites="kim_centrifuge_2016">[<span class="citeproc-not-found" data-reference-id="kim_centrifuge_2016"><strong>???</strong></span>]</span>.</p>
<p>Once each sequence (from raw reads or assembled contigs) has a taxonomic assignment,
<!-- David comment: "Not all profiles classify sequences. See Focus, Quikr, Metalign, Metapalette, etc" -->
these methods resolve the final identity and abundance for each member of the community by summarizing the assignments to a specific taxonomic rank,
Taxonomic profiling is fundamentally limited by the availability of reference datasets to be used for assignments,
and reporting what percentage of the sample is unassigned is important to assess results,
especially in undercharacterized environments such as oceans and soil.</p>
<h1 id="results">Results</h1>
<h2 id="scaled-minhash-sketches-support-containment-operations">Scaled MinHash sketches support containment operations</h2>
<ul>
<li>scaled minhash supports similarity and containment</li>
</ul>
<p>The Scaled MinHash is a mix of MinHash and ModHash.
From the former it keeps the smallest elements,
and from the latter it adopts the dynamic size to allow containment estimation.
Instead of taking <span class="math inline">\(0 \mod m\)</span> elements like <span class="math inline">\(\mathbf{MOD}_m(W)\)</span>,
a Scaled MinHash uses a parameter <span class="math inline">\(s\)</span> to select a subset of <span class="math inline">\(W\)</span>:
<span class="math display">\[\mathbf{SCALED}_s(W) = \{\,w \leq \frac{H}{s} \mid \forall w \in W\,\}\]</span>
where <span class="math inline">\(H\)</span> is the largest possible value in the domain of <span class="math inline">\(h(x)\)</span> and
<span class="math inline">\(\frac{H}{s}\)</span> is the  value in the Scaled MinHash.</p>
<p>Given an uniform hash function <span class="math inline">\(h\)</span> and <span class="math inline">\(s=m\)</span>,
the cardinalities of <span class="math inline">\(\mathbf{SCALED}_s(W)\)</span> and <span class="math inline">\(\mathbf{MOD}_m(W)\)</span> converge for large <span class="math inline">\(\vert W \vert\)</span>.
The main difference is the range of possible values in the hash space,
since the Scaled MinHash range is contiguous and the ModHash range is not.
Figure  shows an example comparing MinHash, ModHash and Scaled MinHash with the same parameter value.</p>
<h2 id="scaled-minhash-accurately-estimates-containment">Scaled MinHash accurately estimates containment</h2>
<p>maybe split into two: definition, and then benchmarking.</p>
<p>second results section would be, “Scaled minhash has good performance…”</p>
<ul>
<li>compares well with others</li>
<li>supports large-scale sketching of genbank</li>
</ul>
<p>xx How much is missed figure; Poisson calculations?</p>
<p>In this section the <em>Scaled MinHash</em> method implemented in <code>smol</code>
is compared to CMash (<em>Containment MinHash</em>)
and Mash Screen (<em>Containment Score</em>) for containment queries
in the Shakya dataset <span class="citation" data-cites="shakya_comparative_2013">[<span class="citeproc-not-found" data-reference-id="shakya_comparative_2013"><strong>???</strong></span>]</span>,
a synthetic mock metagenomic bacterial and archaeal community where the organisms are known,
including low-coverage and contaminant genomes described in <span class="citation" data-cites="awad_evaluating_2017">[<span class="citeproc-not-found" data-reference-id="awad_evaluating_2017"><strong>???</strong></span>]</span> and <span class="citation" data-cites="ondov_mash_2019">[<span class="citeproc-not-found" data-reference-id="ondov_mash_2019"><strong>???</strong></span>]</span>.</p>
<p><code>smol</code> is a minimal implementation of <em>Scaled MinHash</em> for demonstration of the method
and doesn’t include many required features for working with real biological data,
but its smaller code base makes it a more readable and concise example of the method.
For <em>Mash Screen</em> the ratio of hashes matched by total hashes is used instead of the <em>Containment Score</em>,
since the latter uses a <span class="math inline">\(k\)</span>-mer survival process modeled as a Poisson process
first introduced in <span class="citation" data-cites="fan_assembly_2015">[<span class="citeproc-not-found" data-reference-id="fan_assembly_2015"><strong>???</strong></span>]</span> and later used in the <em>Mash distance</em> <span class="citation" data-cites="ondov_mash:_2016">[<span class="citeproc-not-found" data-reference-id="ondov_mash:_2016"><strong>???</strong></span>]</span> and
<em>Containment score</em> <span class="citation" data-cites="ondov_mash_2019">[<span class="citeproc-not-found" data-reference-id="ondov_mash_2019"><strong>???</strong></span>]</span> formulations.</p>
<p>Experiments use <span class="math inline">\(k=\{21, 31, 51\}\)</span>
(except for Mash, which only supports <span class="math inline">\(k \le 32\)</span>).
For Mash and CMash they were run with <span class="math inline">\(n=\{1000, 10000\}\)</span>
to evaluate the containment estimates when using larger sketches with sizes
comparable to the Scaled MinHash sketches with <span class="math inline">\(scaled=1000\)</span>.
The truth set is calculated using an exact <span class="math inline">\(k\)</span>-mer counter implemented with a
<em>HashSet</em> data structure in the Rust programming language <span class="citation" data-cites="matsakis_rust_2014">[<span class="citeproc-not-found" data-reference-id="matsakis_rust_2014"><strong>???</strong></span>]</span>.</p>
<p><code>{r minhash1000, eval=TRUE, echo=FALSE, message=FALSE, error=FALSE, warning=FALSE, cache=TRUE, out.width="100%", auto_pdf=TRUE, fig.cap='(ref:minhash1000)', fig.show="hold", fig.align="center"} knitr::include_graphics('../experiments/smol_gather/figures/containment.pdf')</code></p>
<p>(ref:minhash1000) Letter-value plot <span class="citation" data-cites="hofmann_letter-value_2017">[<span class="citeproc-not-found" data-reference-id="hofmann_letter-value_2017"><strong>???</strong></span>]</span> of the
differences from containment estimate to ground truth (exact).
Each method is evaluated for <span class="math inline">\(k=\{21,31,51\}\)</span>,
except for <code>Mash</code> with <span class="math inline">\(k=51\)</span>,
since <code>Mash</code> doesn’t support <span class="math inline">\(k&gt;32\)</span>.
<strong>A</strong>: Using all 68 reference genomes found in previous articles.
<strong>B</strong>: Excluding low coverage genomes identified in previous articles.</p>
<p>All methods are within 1% of the exact containment on average (Figure  A),
with <code>CMash</code> consistently underestimating the containment for large <span class="math inline">\(k\)</span> and overestimating for
small <span class="math inline">\(k\)</span>.
<code>Mash Screen</code> with <span class="math inline">\(n=10000\)</span> has the smallest difference to ground truth for <span class="math inline">\(k=\{21, 31\}\)</span>,
followed by <code>smol</code> with <code>scaled=1000</code> and <code>Mash Screen</code> with <span class="math inline">\(n=1000\)</span>.</p>
<p>In order to evaluate the effect of the low-coverage and contaminant genomes
previously detected in this dataset,
(Figure  B) shows results with these genomes removed.
The number of outliers is greatly reduced,
with all methods mostly within 1% absolute difference to the ground truth.
<code>CMash</code> still has some outliers with up to 8% difference to the ground truth.</p>
<!-- TODO
  * runtimes?
-->
<div id="fig:containment" class="fignos">
<figure>
<img src="images/containment.svg" alt="" /><figcaption><span>Figure 1:</span> <strong>Letter-value plot of the
differences from containment estimate to ground truth (exact).</strong>
Each method is evaluated for <span class="math inline">\(k=\{21,31,51\}\)</span>,
except for <code>Mash</code> with <span class="math inline">\(k=51\)</span>,
since <code>Mash</code> doesn’t support <span class="math inline">\(k&gt;32\)</span>.
<strong>A</strong>: Using all 68 reference genomes found in previous articles.
<strong>B</strong>: Excluding low coverage genomes identified in previous articles.</figcaption>
</figure>
</div>
<p>CTB: Where does “Scaled MinHash sketch sizes across GenBank domains” go? (Chp 01 from Luiz thesis)</p>
<p>A drawback of Scaled MinHash when compared to regular MinHash sketches is the size:
the MinHash parameter <span class="math inline">\(s\)</span> sets an upper bound on the size of the sketch,
independently of the size of the original data.
Scaled MinHash sketches grow proportionally to the original data cardinality,
and in the worst case can have up to <span class="math inline">\(\frac{H}{s}\)</span> items.</p>
<p><em>Scaled MinHash</em> sketches offer a fixed range of possible hash values,
but with reduced sensitivity for small datasets when using larger <span class="math inline">\(s\)</span> (scaled) values.
A biological example are viruses:
at <span class="math inline">\(s=2000\)</span> many viruses are too small to consistently have a hashed value
selected by the <em>Scaled MinHash</em> approach.
Other <em>MinHash</em> approaches sidestep the problem by using hashing and streaming the query dataset (<code>Mash Screen</code>)
or loading the query dataset into an approximate query membership data structure (<code>CMash</code>) to allow comparisons
with the variable range of possible hash values,
but both solutions require the original data or a more limited data representation than <em>Scaled MinHash</em>.
The consistency of operating in the same data structure also allows further
methods to be develop using only <em>Scaled MinHash</em> sketches and their features,
especially if large collections of <em>Scaled MinHash</em> sketches are available.</p>
<h2 id="scaled-minhash-sketches-support-efficient-indexing-for-large-scale-containment-queries">Scaled MinHash sketches support efficient indexing for large-scale containment queries</h2>
<p>Efficient indexing of scaled minhash signatures is cool.</p>
<ul>
<li>hierarchical and inverted indices (SBT and LCA)</li>
<li>supports efficient containment and similarity queries</li>
</ul>
<p>Searching for matches in large collection of datasets is challenging when hundreds of thousands of them are available,
especially if they are partitioned and the data is not all present at the same place,
or too large to even be stored in a single system.
Efficient methods for sequencing datasets use exact <span class="math inline">\(k\)</span>-mer matching instead of relying on sequence alignment,
but sensitivity is reduced since they can’t deal with sequencing errors and biological variation as well as alignment-based methods can.</p>
<p>CTB: Additional points to raise: in-memory representation of sketches may be too big (!!),
goal here is on disk storage/low minimum memory for “extremely large data” situation.
Also/in addition, want ability to do incremental loading of things.
Note we are not talking here about situations where the indices themselves are too big to download,
could maybe include forward pointer to chp4.</p>
<p>Note, in this section we could also include distinction in performance between SBT and LCA DB,
to whit: large scaled works well with LCA (small DB, ~tolerable memory, load all at once, then quite fast)
but low scaled may work (much) better with SBT.</p>
<p><code>sourmash</code> <span class="citation" data-cites="brown_sourmash:_2016">[<span class="citeproc-not-found" data-reference-id="brown_sourmash:_2016"><strong>???</strong></span>]</span> is a software for large-scale sequence data comparisons based on MinHash sketches.
Initially implementing operations for computing,
comparing and plotting distance matrices for <em>MinHash</em> sketches,
version 2 <span class="citation" data-cites="pierce_large-scale_2019">[<span class="citeproc-not-found" data-reference-id="pierce_large-scale_2019"><strong>???</strong></span>]</span> introduces <em>Scaled MinHash</em> sketches
and indices for this new sketch format.
Indices support a common set of operations
(insertion, search, and returning all signatures are the main ones),
allowing them to be used interchangeably depending on the use case,
performance requirements and computational resources available.</p>
<p>The simplest index is the <code>LinearIndex</code>,
a list of signatures.
Search operations are executed sequentially,
and insertions append new signatures to the end of the list.
Internally,
<code>sourmash</code> uses LinearIndex as the default index for lists of
signatures provided in the command-line.</p>
<p>The <em>MinHash Bloom Tree</em> (<em>MHBT</em>) is a variation of the <em>Sequence Bloom Tree</em> (<em>SBT</em>)
that uses Scaled MinHash sketches as leaf nodes instead of Bloom Filters as in
the SBT.
The search operation in SBTs is defined as a breadth-first search starting at the root of the tree,
using a threshold of the original <span class="math inline">\(k\)</span>-mers in the query to decide when to prune the search.
MHBTs use a query Scaled MinHash sketch instead,
but keep the same search approach.
The threshold of a query <span class="math inline">\(Q\)</span> approach introduced in <span class="citation" data-cites="solomon_fast_2016">[<span class="citeproc-not-found" data-reference-id="solomon_fast_2016"><strong>???</strong></span>]</span> is
equivalent to the containment
<span class="math display">\[C(Q, S) = \frac{\vert Q \cap S \vert }{\vert S \vert}\]</span>
described in <span class="citation" data-cites="broder_resemblance_1997">[<span class="citeproc-not-found" data-reference-id="broder_resemblance_1997"><strong>???</strong></span>]</span>,
where <span class="math inline">\(S\)</span> is a Scaled MinHash sketch.
For internal nodes <span class="math inline">\(n\)</span> (which are Bloom Filters) the containment of the query Scaled MinHash sketch <span class="math inline">\(Q\)</span> is
<span class="math display">\[C(Q, n) = \frac{\vert \{\,h \in n \mid \forall h \in Q\,\} \vert}{\vert Q \vert}\]</span>
the same containment score defined in <span class="citation" data-cites="koslicki_improving_2019">[<span class="citeproc-not-found" data-reference-id="koslicki_improving_2019"><strong>???</strong></span>]</span> for the <em>Containment MinHash</em> to <em>Bloom Filter</em> comparison.</p>
<p>MHBTs support both containment and similarity queries.
For internal nodes the containment <span class="math inline">\(C(Q,n)\)</span> is used as an upper-bound of the similarity <span class="math inline">\(J(Q, n)\)</span>:
<span class="math display">\[\begin{equation}
\begin{split}
  C(Q, n) &amp;\ge J(Q, n) \\
  \frac{\vert Q \cap n \vert }{\vert Q \vert} &amp;\ge \frac{\vert Q \cap n \vert }{\vert Q \cup n \vert}
\end{split}
\end{equation}\]</span>
since <span class="math inline">\(\vert Q \cup n \vert \ge \vert Q \vert\)</span>.
When a leaf node is reached then the similarity <span class="math inline">\(J(Q, S)\)</span> is calculated for the Scaled MinHash sketch <span class="math inline">\(S\)</span>
and declared a match if it is above the threshold <span class="math inline">\(t\)</span>.
Because the upper-bound is being used,
this can lead to extra nodes being checked,
but it simplifies implementation and provides better correctness guarantees.</p>
<p>The LCA index in sourmash is an inverted index that stores a mapping from hashes
in a collection of signatures to a list of IDs for signatures containing the hash.
Despite the name,
the list of signature IDs is not collapsed to the lowest common ancestor (as in kraken),
and is calculated as needed by downstream methods using the taxonomy information
that is also stored separately in the LCA index.</p>
<p>The mapping from hashes to signature IDs in the LCA index is an implicit representation of the original signatures used to build the index,
and so returning the signatures is implemented by rebuilding the original signatures on-the-fly.
Search in an LCA index matches the <span class="math inline">\(k\)</span>-mers in the query to the list of signatures IDs containing them,
using a counter data structure to sort results by number of hashes per signature ID.
The rebuilt signatures are then returned as matches based on the signature ID,
with containment or similarity to the query calculated against the rebuilt signatures.</p>
<p>mash screen <span class="citation" data-cites="ondov_mash_2019">[<span class="citeproc-not-found" data-reference-id="ondov_mash_2019"><strong>???</strong></span>]</span> has a similar index,
but it is constructed on-the-fly using the distinct hashes in a sketch collection as keys,
and values are counters initially set to zero.
As the query is processed,
matching hashes have their counts incremented,
and after all hashes in the query are processed then all the sketches in the collection are
checked in the counters to quantify the containment/similarity of each sketch in the query.
The LCA index uses the opposite approach,
opting to reconstruct the sketches on-the-fly.</p>
<p>In order to evaluate MHBT and LCA indices construction a GenBank snapshot from July 18, 2020,
containing 725,331 assembled genomes (
5,282 Archaea,
673,414 Bacteria,
6,601 Fungi
933 Protozoa and
39,101 Viral) <!-- TODO add total data size here? need to calculate... -->
was used to measure runtime,
memory consumption and final index size.
MHBT indices were built with <span class="math inline">\(scaled=1000\)</span>,
and LCA indices used <span class="math inline">\(scaled=10000\)</span>.
Table @ref(tab:lca-index) shows the results for the LCA index,
and Table @ref(tab:mhbt-index) for the MHBT index.</p>
<table>
<caption>(#tab:lca-index) Results for LCA indexing,
with <span class="math inline">\(scaled=10000\)</span> and <span class="math inline">\(k=21\)</span>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Domain</th>
<th style="text-align: right;">Runtime (s)</th>
<th style="text-align: right;">Memory (MB)</th>
<th style="text-align: right;">Size (MB)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Viral</td>
<td style="text-align: right;">57</td>
<td style="text-align: right;">33</td>
<td style="text-align: right;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">Archaea</td>
<td style="text-align: right;">58</td>
<td style="text-align: right;">30</td>
<td style="text-align: right;">5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Protozoa</td>
<td style="text-align: right;">231</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">17</td>
</tr>
<tr class="even">
<td style="text-align: left;">Fungi</td>
<td style="text-align: right;">999</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">65</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Bacteria</td>
<td style="text-align: right;">12,717</td>
<td style="text-align: right;">857</td>
<td style="text-align: right;">446</td>
</tr>
</tbody>
</table>
<table>
<caption>(#tab:mhbt-index) Results for MHBT indexing,
with <span class="math inline">\(scaled=1000\)</span>, <span class="math inline">\(k=21\)</span> and internal nodes (Bloom Filters)
using 10000 slots for storage.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Domain</th>
<th style="text-align: right;">Runtime (s)</th>
<th style="text-align: right;">Memory (MB)</th>
<th style="text-align: right;">Size (MB)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Viral</td>
<td style="text-align: right;">126</td>
<td style="text-align: right;">326</td>
<td style="text-align: right;">77</td>
</tr>
<tr class="even">
<td style="text-align: left;">Archaea</td>
<td style="text-align: right;">111</td>
<td style="text-align: right;">217</td>
<td style="text-align: right;">100</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Protozoa</td>
<td style="text-align: right;">206</td>
<td style="text-align: right;">753</td>
<td style="text-align: right;">302</td>
</tr>
<tr class="even">
<td style="text-align: left;">Fungi</td>
<td style="text-align: right;">1,161</td>
<td style="text-align: right;">3,364</td>
<td style="text-align: right;">1,585</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Bacteria</td>
<td style="text-align: right;">32,576</td>
<td style="text-align: right;">47,445</td>
<td style="text-align: right;">24,639</td>
</tr>
</tbody>
</table>
<p>Index sizes are more affected by the number of genomes inserted than the
individual <em>Scaled MinHash</em> sizes.
Despite Protozoan and Fungal <em>Scaled MinHash</em> sketches being larger individually,
the Bacterial indices are an order of magnitude larger for both indices since
they contain two orders of magnitude more genomes.</p>
<p>Comparing between LCA and MHBT index sizes must account for their different scaled parameters,
but as shown in Chapter <a href="#chp-scaled">1</a> a <em>Scaled MinHash</em> with <span class="math inline">\(scaled=1000\)</span> when downsampled to <span class="math inline">\(scaled=10000\)</span>
is expected to be ten times smaller.
Even so,
MHBT indices are more than ten times larger than their LCA counterparts,
since they store extra caching information
(the internal nodes)
to avoid loading all the data to memory during search.
LCA indices also contain extra data
(the list of datasets containing a hash),
but this is lower than the storage requirements for the MHBT internal nodes.</p>
<p>or the purpose of evaluating the performance characteristics of MHBT and LCA indices when performing searches,
each of the previously described indices generated from GenBank domains was used
to execute similarity searches (finding datasets in a collection that are similar to a query)
using appropriate queries for each domain.
All queries were selected from the relevant domain and queried against both MHBT (<span class="math inline">\(scaled=1000\)</span>) and LCA (<span class="math inline">\(scaled=10000\)</span>),
for <span class="math inline">\(k=21\)</span>.</p>
<table>
<caption>(#tab:search-runtime) Running time in seconds for similarity search
using LCA (<span class="math inline">\(scaled=10000\)</span>) and MHBT (<span class="math inline">\(scaled=1000\)</span>) indices.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">Viral</th>
<th style="text-align: right;">Archaea</th>
<th style="text-align: right;">Protozoa</th>
<th style="text-align: right;">Fungi</th>
<th style="text-align: right;">Bacteria</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">LCA</td>
<td style="text-align: right;">1.06</td>
<td style="text-align: right;">1.42</td>
<td style="text-align: right;">5.40</td>
<td style="text-align: right;">26.92</td>
<td style="text-align: right;">231.26</td>
</tr>
<tr class="even">
<td style="text-align: left;">SBT</td>
<td style="text-align: right;">1.32</td>
<td style="text-align: right;">3.77</td>
<td style="text-align: right;">43.51</td>
<td style="text-align: right;">244.77</td>
<td style="text-align: right;">3,185.88</td>
</tr>
</tbody>
</table>
<table>
<caption>(#tab:search-memory) Memory consumption in megabytes for similarity search
using LCA (<span class="math inline">\(scaled=10000\)</span>) and MHBT (<span class="math inline">\(scaled=1000\)</span>) indices.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">Viral</th>
<th style="text-align: right;">Archaea</th>
<th style="text-align: right;">Protozoa</th>
<th style="text-align: right;">Fungi</th>
<th style="text-align: right;">Bacteria</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">LCA</td>
<td style="text-align: right;">223</td>
<td style="text-align: right;">240</td>
<td style="text-align: right;">798</td>
<td style="text-align: right;">3,274</td>
<td style="text-align: right;">20,926</td>
</tr>
<tr class="even">
<td style="text-align: left;">SBT</td>
<td style="text-align: right;">163</td>
<td style="text-align: right;">125</td>
<td style="text-align: right;">332</td>
<td style="text-align: right;">1,656</td>
<td style="text-align: right;">2,290</td>
</tr>
</tbody>
</table>
<p>Table @ref(tab:search-runtime) shows running time for both indices.
For small indices (Viral and Archaea) the LCA running time is dominated by loading the index in memory,
but for larger indices the cost is amortized due to the faster running times.
This situation is clearer for the Bacteria indices,
where the LCA search completes in 3 minutes and 51 seconds,
while the SBT search takes 54 minutes.</p>
<p>When comparing memory consumption,
the situation is reversed.
Table @ref(tab:search-memory) shows how the LCA index consistently uses twice the memory for all domains,
but for larger indices like Bacteria it uses as much as 10 times the memory as
the MHBT index for the same data.</p>
<p>For both runtime and memory consumption,
it is worth pointing that the LCA index is a tenth of the data indexed by the MHBT.
This highlights the trade-off between speed and memory consumption for both approaches,
especially for larger indices.</p>
<h2 id="metagenome-sketches-can-be-accurately-decomposed-into-constituent-genomes-by-a-greedy-algorithm-gather">Metagenome sketches can be accurately decomposed into constituent genomes by a greedy algorithm, ‘gather’</h2>
<p>Greedy decomposition of metagenome sketches by k-mer containment is accurate</p>
<p>Greedy decomposition of metagenomes by k-mer containment (gather) is cool.</p>
<ul>
<li>outline algorithm</li>
<li>compare conceptually vs least/lowest common ancestor approaches; combinatorial</li>
<li>showcase some examples on synthetic data</li>
</ul>
<p>Methods summarizing taxonomic assignments from sequences in the query metagenome to calculate the profile for the community follow a bottom-up approach.
<code>gather</code> is a new method following a top-down approach:
starting from the <span class="math inline">\(k\)</span>-mer composition of the query,
it iteratively finds a match in a collection of datasets with the largest <em>containment</em> of the query (most elements in common),
and create a new query by <em>removing elements</em> in the match from the original query.
The process stops when the new query doesn’t have any more matches in the collection,
or a user-provided minimum detection threshold is reached.
<!-- David comment: "I'm surprised this works, since back in 2015 (Metapalette
days) I found removing elements like this caused the approach to fall apart when
closely-related organisms are in the metagenome.)
-->
This approach differs from previous methods because the co-occurrence of <span class="math inline">\(k\)</span>-mers
in a match is considered a strong signal that they are coming from the same organism in the original sample,
and is used instead of the LCA-based methods to resolve ambiguities in the taxonomic assignment of a sequence (or its <span class="math inline">\(k\)</span>-mers).</p>
<p>Any data structure supporting both the <em>containment</em>
<span class="math inline">\(C(A, B) = \frac{\vert A \cap B \vert }{\vert A \vert}\)</span>
and <em>remove elements</em> operations can be used as a query with <code>gather</code>.
For example,
a <em>set</em> of the <span class="math inline">\(k\)</span>-mer composition of the query supports element removal,
and calculating containment can be done with regular set operations.
Approximate membership query (AMQ) sketches like the <em>Counting Quotient Filter</em> <span class="citation" data-cites="pandey_general-purpose_2017">[<span class="citeproc-not-found" data-reference-id="pandey_general-purpose_2017"><strong>???</strong></span>]</span> can also be used,
with the benefit of reduced storage and memory usage.
Moreover,
the collection of datasets can be implemented with any data structure that can do containment comparisons with the query data structure,
including implicit representations like an inverted index from hashed <span class="math inline">\(k\)</span>-mers to dataset IDs (as detailed in subsection <a href="#inverted-index">2.1.2</a>).</p>
<!-- TODO crossref with section/subsection is not using all the numbers (only the chapter)... -->
<p><em>Scaled MinHash</em> sketches (section <a href="#scaled-minhash">1.2</a>) are a subset of the <span class="math inline">\(k\)</span>-mer composition <span class="math inline">\(M\)</span> of a dataset,
with the guarantee that if a hash <span class="math inline">\(w&#39;=h(m)\)</span> of <span class="math inline">\(k\)</span>-mer <span class="math inline">\(m \in M\)</span> is present in the <em>Scaled MinHash</em> sketch with scaled parameter <span class="math inline">\(s\)</span>
<span class="math display">\[\mathbf{SCALED}_s(W) = \{\,w \leq \frac{H}{s} \mid \forall w \in W\,\}\]</span>
where <span class="math inline">\(W = \{\,h(m) \mid \forall m \in M\,\}\)</span>,
<span class="math inline">\(h(x)\)</span> is an uniform hash function and <span class="math inline">\(H\)</span> is the maximum value possible for <span class="math inline">\(h(.)\)</span>,
the same hash <span class="math inline">\(w&#39;\)</span> will be present in sketches for other datasets also containing the <span class="math inline">\(k\)</span>-mer <span class="math inline">\(m\)</span>,
as long as they have the same parameter <span class="math inline">\(s\)</span> or can be downsampled to the same <span class="math inline">\(s\)</span>.
This is not guaranteed for regular <em>MinHash</em> sketches, <!-- TODO because fixed size explanation -->
and is what allows removing elements from the <em>Scaled MinHash</em> sketch of a query once a match is found.
Since the containment of two datasets can also be estimated directly from their <em>Scaled MinHash</em> sketches,
they are viable data structures for <code>gather</code>,
especially since they are only a small fraction of the original dataset size and easier to store,
manipulate and share.</p>
<p><em>Scaled MinHash</em> sketches can be stored in any data structure for representing the <span class="math inline">\(k\)</span>-mer composition <span class="math inline">\(M\)</span> of a dataset <span class="citation" data-cites="marchet_data_2019">[<span class="citeproc-not-found" data-reference-id="marchet_data_2019"><strong>???</strong></span>]</span>,
and as a subset of <span class="math inline">\(M\)</span> they can also be indexed by approaches for the full <span class="math inline">\(k\)</span>-mer composition.
<code>sourmash</code> <span class="citation" data-cites="pierce_large-scale_2019">[<span class="citeproc-not-found" data-reference-id="pierce_large-scale_2019"><strong>???</strong></span>]</span> defines the MinHash Bloom Tree (<em>MHBT</em>) index,
a <span class="math inline">\(k\)</span>-mer aggregative method with explicit representation of datasets based on hierarchical indices and a specialization of the Sequence Bloom Tree <span class="citation" data-cites="solomon_fast_2016">[<span class="citeproc-not-found" data-reference-id="solomon_fast_2016"><strong>???</strong></span>]</span>,
as well as the <em>LCA</em> index,
a color-aggregative method with implicit representation of the datasets based on inverted indices.</p>
<p>Compared to previous taxonomic profiling methods,
<em>Scaled MinHash</em> can also be seen as a mix of two other approaches:
It uses exact <span class="math inline">\(k\)</span>-mer matching and assignment,
and the <span class="math inline">\(k\)</span>-mers selected by the MinHashing process are equivalent to implicitly-defined markers.
It differs from previous approaches because only a subset of the <span class="math inline">\(k\)</span>-mer composition is used for matching,
and traditional gene markers are explicitly chosen due to sequence conservation and low mutation rates,
while MinHashing <span class="math inline">\(k\)</span>-mers generates a randomized,
but consistent across datasets,
set of marker <span class="math inline">\(k\)</span>-mers.</p>
<p>CTB note: gather can be done on exact k-mers as well.</p>
<h2 id="taxonomic-profiling-based-on-gather-is-accurate">Taxonomic profiling based on ‘gather’ is accurate</h2>
<p>constituent gather is cool.</p>
<ul>
<li>CAMI results</li>
<li>suggests gather/greedy decomposition is pretty good</li>
</ul>
<p>Taxonomic profiling in <code>sourmash</code> is built as an extra step on top of the <code>gather</code> algorithm.
<code>gather</code> returns assignments to a dataset in a collection,
and based on that assignment the extra step associates a taxonomic ID
(based on some dataset identifier)
and a taxonomic lineage (a path from root to taxonomic ID) derived from a specific taxonomy.
After a lineage is available,
each taxonomic rank is summarized based on the abundances under it.</p>
<!-- TODO expand a bit -->
<!-- TODO: a diagram here, leave the algorithm for the methods section -->
<!-- Future paper TODO: demonstrate gather on top of other approaches? kraken/mantis/kProcessor? -->
<p>The Critical Assessment of Metagenome Intepretation (CAMI) <span class="citation" data-cites="sczyrba_critical_2017">[<span class="citeproc-not-found" data-reference-id="sczyrba_critical_2017"><strong>???</strong></span>]</span> is a community-driven initiative
bringing together tool developers and users to create standards for reproducibly benchmarking metagenomic methods.
Challenges are organized around datasets representing microbial communities of interest in metagenomics,
like marine,
high-strain and rhizosphere datasets.
Sequencing data is generated by CAMISIM <span class="citation" data-cites="fritz_camisim_2019">[<span class="citeproc-not-found" data-reference-id="fritz_camisim_2019"><strong>???</strong></span>]</span>,
a microbial community and metagenome simulator using a gold standard with a known community composition
to model different aspects
(diversity levels, abundances and sequencing technologies features)
of these datasets.</p>
<p>Each challenge typically includes three tasks:
assembly,
taxonomic profiling and binning (at taxon or genome levels).
Since there is a standard output format that tools need to implement,
performance comparisons can be streamlined.
CAMI provides a set of tools for computing performance metrics for each group:
MetaQUAST for assembly,
AMBER for binning,
and OPAL <span class="citation" data-cites="meyer_assessing_2019">[<span class="citeproc-not-found" data-reference-id="meyer_assessing_2019"><strong>???</strong></span>]</span> for taxonomic profiling evaluation.</p>
<p><code>gather</code> can be used for the taxonomic profiling task,
where the goal is finding what organisms are present in a metagenome sampled from a microbial community,
and what are their relative abundances.
Taxonomic profiling is based on a predetermined taxonomy of known organisms,
as well as a collection of genomes for each organism.
It differs from taxonomic classification,
where each read or sequence in the metagenome is given a taxonomic assignment,
and from binning,
which aims to cluster reads or sequences into bins,
possibly representing unknown organisms.</p>
<p>The first set of CAMI challenges happened in 2015 and results were published in 2017.
Since then more tools were developed and improved,
as well as reference databases growing in size and diversity.
Reproducing the running environment used by the original tools is challenging,
even with all the focus on reproducibility by the organizers and community.</p>
<!--- TODO: bring back later, CAMI II is more interesting and enough for discussing results?
#### The first set of CAMI challenges
The initial CAMI challenges [@sczyrba_critical_2017] included three datasets based on genome sequences from
689 bacterial and archaeal isolates (cultured organisms) and 598 sequences derived from plasmids,
viruses and other circular elements.
Each challenge dataset simulates 150-bp paired-end reads with Illumina HighSeq error profiles,
with varying levels of complexity:
 - _low_, a single 15-Gbp sample with 40 genomes and 20 circular elements;
 - _medium_, two samples with 132 genomes and 100 circular elements, totalling 40-Gbp;
 - _high_, a five-sample time series with 596 genomes and 478 circular elements), totalling 75-Gbp.
All datasets also simulate realistic characteristics from sequenced metagenomes,
including species with strain-level diversity,
presence of viruses, plasmids and other circular elements,
and genomes covering distinct evolutionary distances,
with the goal of measuring how these characteristics impact the performance of each method.
-->
<!-- Urgent TODO: medium and high datasets!  -->
<!-- TODO: comment results from CAMI low -->
<!--
```{r gatherCAMIlowTable, eval=TRUE, echo=FALSE, message=FALSE, error=FALSE, warning=FALSE, cache=TRUE, out.width="100%", auto_pdf=TRUE, fig.cap="CAMI I Low table"}
knitr::include_graphics('figure/cami_i_low_table.png')
```
```{r gatherCAMIlowSpider, eval=TRUE, echo=FALSE, message=FALSE, error=FALSE, warning=FALSE, cache=TRUE, out.width="100%", auto_pdf=TRUE, fig.cap="CAMI I Low spider plot"}
knitr::include_graphics('figure/cami_i_low_recall_precision.png')
```
-->
<!-- TODO
- low and medium datasets have viruses, which are not in sourmash indices
-->
<h4 id="cami-ii-mouse-gut-metagenome-dataset">CAMI II mouse gut metagenome dataset</h4>
<p>The CAMI initiative released new challenges in 2019 (marine, high-strain and pathogen detection)
and 2020 (rhizosphere),
with updated processes for submission,
evaluation and participation.
In addition to short-read sequencing data matching Illumina profiles,
it also includes long-read sequencing data with PacBio and Nanopore profiles,
allowing further benchmarks and comparisons.
CAMI also provides a snapshot of the RefSeq reference genomes for building specialized databases for each tool,
as well with an NCBI Taxonomy to minimize differences in taxonomic reports.
Since challenges only release the gold standard after they are concluded and published,
results for comparison with new methods are still pending.</p>
<p>The CAMI II mouse gut metagenome <span class="citation" data-cites="meyer_tutorial_2020">[<span class="citeproc-not-found" data-reference-id="meyer_tutorial_2020"><strong>???</strong></span>]</span> is a toy dataset,
used for preparing and calibrating tools for other CAMI II challenges.
Similar to the concluded challenges from CAMI,
it provides gold standards for expected microbial community composition,
including presence and relative abundance of organisms.
The simulated mouse gut metagenome (<em>MGM</em>) was derived from 791 bacterial and archaeal genomes,
representing 8 phyla,
18 classes,
26 orders,
50 families,
157 genera,
and 549 species.
64 samples were generated with <em>CAMISIM</em>,
with 91.8 genomes present on each sample on average.
Each sample is 5 GB in size,
and both short-read (Illumina) and long-read (PacBio) sequencing data is available.</p>
<p>Because the official challenges don’t have gold standards published yet,
it is currently the only alternative for using the CAMI benchmarking tools to evaluate new methods with updated datasets.
Curated metadata for multiple tools is also available,
and users can submit their tools for inclusion.
All tools currently in the curated metadata repository use the short-read samples.</p>
<p><code>{r gatherCAMImgSpider, eval=TRUE, echo=FALSE, message=FALSE, error=FALSE, warning=FALSE, cache=TRUE, out.width="75%", auto_pdf=TRUE, fig.cap='(ref:cami2caption)', fig.show="hold", fig.align="center"} knitr::include_graphics(c('../experiments/profiling/figures/spider_plot_relative.pdf',                           '../experiments/profiling/figures/ranks_by_tool.pdf',                           '../experiments/profiling/figures/scores.pdf'))</code></p>
<p>(ref:cami2caption) Updated Fig. 6 from <span class="citation" data-cites="meyer_tutorial_2020">[<span class="citeproc-not-found" data-reference-id="meyer_tutorial_2020"><strong>???</strong></span>]</span> including <code>sourmash</code>.
<strong>a</strong> Comparison per taxonomic rank of methods in terms of completeness, purity (1% filtered), and L1 norm.
<strong>b</strong> Performance per method at all major taxonomic ranks, with the shaded bands showing the standard deviation of a metric.
In <strong>a</strong> and <strong>b</strong>, completeness, purity, and L1 norm error range between 0 and 1.
The L1 norm error is normalized to this range and is also known as Bray-Curtis distance.
The higher the completeness and purity, and the lower the L1 norm, the better the profiling performance.
<strong>c</strong> Methods rankings and scores obtained for the different metrics over all samples and taxonomic ranks.
For score calculation, all metrics were weighted equally.</p>
<p>Figure @ref(fig:gatherCAMImgSpider) is an updated version of Figure 6 from <span class="citation" data-cites="meyer_tutorial_2020">[<span class="citeproc-not-found" data-reference-id="meyer_tutorial_2020"><strong>???</strong></span>]</span> including <code>sourmash</code>,
comparing 10 different methods for taxonomic profiling and their characteristics at each taxonomic rank.
While previous methods show reduced completeness,
the ratio of taxa correctly identified in the ground truth,
below the genus level,
<code>sourmash</code> can reach 88.7% completeness at the species level with the highest
purity (the ratio of correctly predicted taxa over all predicted taxa) across
all methods:
95.9% when filtering predictions below 1% abundance,
and 97% for unfiltered results.
<code>sourmash</code> also has the lowest L1-norm error
(the sum of the absolute difference between the true and predicted abundances at
a specific taxonomic rank),
the highest number of true positives and the lowest number of false positives.</p>
<table>
<caption>(#tab:gather-cami2) Updated Supplementary Table 12 from <span class="citation" data-cites="meyer_tutorial_2020">[<span class="citeproc-not-found" data-reference-id="meyer_tutorial_2020"><strong>???</strong></span>]</span>.
Elapsed (wall clock) time (h:mm) and maximum resident set size
(kbytes) of taxonomic profiling methods on the 64 short read samples of the CAMI II mouse
gut data set. The best results are shown in bold. Bracken requires to run Kraken, hence the times
required to run Bracken and both tools are shown. The taxonomic profilers were run on a
computer with an Intel Xeon E5-4650 v4 CPU (virtualized to 16 CPU cores, 1 thread per core)
and 512 GB (536.870.912 kbytes) of main memory.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">Taxonomic binner</th>
<th style="text-align: right;">Time (hh:mm)</th>
<th style="text-align: right;">Memory (kbytes)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MetaPhlAn 2.9.21</td>
<td style="text-align: right;">18:44</td>
<td style="text-align: right;">5,139,172</td>
</tr>
<tr class="even">
<td style="text-align: left;">MetaPhlAn 2.2.0</td>
<td style="text-align: right;">12:30</td>
<td style="text-align: right;">1,741,304</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Bracken 2.5 (only Bracken)</td>
<td style="text-align: right;"><strong>0:01</strong></td>
<td style="text-align: right;"><strong>24,472</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">Bracken 2.5 (Kraken and Bracken)</td>
<td style="text-align: right;"><strong>3:03</strong></td>
<td style="text-align: right;">39,439,796</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FOCUS 0.31</td>
<td style="text-align: right;">13:27</td>
<td style="text-align: right;">5,236,199</td>
</tr>
<tr class="even">
<td style="text-align: left;">CAMIARKQuikr 1.0.0</td>
<td style="text-align: right;">16:19</td>
<td style="text-align: right;">27,391,555</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mOTUs 1.1</td>
<td style="text-align: right;">19:50</td>
<td style="text-align: right;"><strong>1,251,296</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">mOTUs 2.5.1</td>
<td style="text-align: right;">14:29</td>
<td style="text-align: right;">3,922,448</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MetaPalette 1.0.0</td>
<td style="text-align: right;">76:49</td>
<td style="text-align: right;">27,297,132</td>
</tr>
<tr class="even">
<td style="text-align: left;">TIPP 2.0.0</td>
<td style="text-align: right;">151:01</td>
<td style="text-align: right;">70,789,939</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MetaPhyler 1.25</td>
<td style="text-align: right;">119:30</td>
<td style="text-align: right;">2,684,720</td>
</tr>
<tr class="even">
<td style="text-align: left;">sourmash 3.4.0</td>
<td style="text-align: right;">16:41</td>
<td style="text-align: right;">5,760,922</td>
</tr>
</tbody>
</table>
<p>When considering resource consumption and running times,
<code>sourmash</code> used 5.62 GB of memory with an <em>LCA index</em> built from the
RefSeq snapshot (141,677 genomes) with <span class="math inline">\(scaled=10000\)</span> and <span class="math inline">\(k=51\)</span>.
Each sample took 597 seconds to run (on average),
totalling 10 hours and 37 minutes for 64 samples.
MetaPhlan 2.9.21 was also executed in the same machine,
a workstation with an AMD Ryzen 9 3900X 12-Core CPU running at 3.80 GHz,
64 GB DDR4 2133 MHz of RAM and loading data from an NVMe SSD,
in order to compare to previously reported times in Table @ref(tab:gather-cami2) <span class="citation" data-cites="meyer_tutorial_2020">[<span class="citeproc-not-found" data-reference-id="meyer_tutorial_2020"><strong>???</strong></span>]</span>.
MetaPhlan took 11 hours and 25 minutes to run for all samples,
compared to 18 hours and 44 minutes previously reported,
and correcting the <code>sourmash</code> running time by this factor it would likely take
16 hours and 41 minutes in the machine used in the original comparison.
After correction,
<code>sourmash</code> has similar runtime and memory consumption to the other best performing tools
(<em>mOTUs</em> and <em>MetaPhlAn</em>),
both gene marker and alignment based tools.</p>
<p>Additional points are that <code>sourmash</code> is a single-threaded program,
so it didn’t benefit from the 16 available CPU cores,
and it is the only tool that could use the full RefSeq snapshot,
while the other tools can only scale to a smaller fraction of it
(or need custom databases).
The CAMI II RefSeq snapshot for reference genomes also doesn’t include viruses;
this benefits <code>sourmash</code> because viral <em>Scaled MinHash</em> sketches are usually not well supported for containment estimation,
since viral sequences require small scaled values to have enough hashes to be reliable.</p>
<h1 id="discussion">Discussion</h1>
<h2 id="scaled-minhash-offers-benefits-drawbacks-vs-regular-minhash">Scaled MinHash offers benefits, drawbacks vs regular MinHash</h2>
<p>Combine theoretical discussion with practical discussion of benefits/drawbacks.</p>
<h2 id="scaled-minhash-supports-operating-directly-on-sketches">Scaled MinHash supports operating directly on sketches</h2>
<p>(CTB: Portions of this may belong in Results)</p>
<p>Once a Scaled MinHash is calculated there are many operation that can be applied without depending on the original data,
saving storage space and allowing scaling analysis to thousands of datasets.
Most of these operations are also possible with MinHash and ModHash,
with caveats.
One example of these operations is :
the contiguous value range for Scaled MinHash sketches allow deriving <span class="math inline">\(\mathbf{SCALED}_{s&#39;}(W)\)</span> sketches for any <span class="math inline">\(s&#39; \ge s\)</span> using only <span class="math inline">\(\mathbf{SCALED}_{s}(W)\)</span>.
MinHash and ModHash can also support this operation,
as long as <span class="math inline">\(n&#39; \le n\)</span> and <span class="math inline">\(m&#39;\)</span> is a multiple of <span class="math inline">\(m\)</span>.</p>
<p>Because Scaled MinHash sketches collect any value below a threshold this also guarantees that once a value is selected it is never discarded.
This is useful in streaming contexts:
any operations that used a previously selected value can be cached and updated with new arriving values.
<span class="math inline">\(\mathbf{MOD}_m(W)\)</span> has similar properties,
but this is not the case for <span class="math inline">\(\mathbf{MIN}_n(W)\)</span>,
since after <span class="math inline">\(n\)</span> values are selected any displacement caused by new data can invalidate previous calculations.</p>
<p>Abundance tracking is another extension to MinHash sketches,
keeping a count of how many times a value appeared in the original data.
This allows filtering for low-abundance values,
as implemented in Finch <span class="citation" data-cites="bovee_finch:_2018">[<span class="citeproc-not-found" data-reference-id="bovee_finch:_2018"><strong>???</strong></span>]</span>,
another MinHash sketching software for genomics.
Filtering values that only appeared once was implemented before in Mash by using a Bloom Filter and only adding values after they were seen once,
with later versions also implementing an extra counter array to keep track of counts for each value in the MinHash.</p>
<p>TODO: discuss here how abundance tracking in MinHash is not “correct”,
because it is not a proper weighted subsample of the data?
Note that Scaled MinHash is a proper weighted subsample.</p>
<p>Other operations are adding and subtracting hash values from a Scaled MinHash sketch,
allowing post-processing and filtering.
Although possible for <span class="math inline">\(\mathbf{MIN}_n(W)\)</span>,
in practice this requires oversampling (using a larger <span class="math inline">\(n\)</span>) to account for possibly having less than <span class="math inline">\(n\)</span> values after filtering
(the approach taken by Finch <span class="citation" data-cites="bovee_finch:_2018">[<span class="citeproc-not-found" data-reference-id="bovee_finch:_2018"><strong>???</strong></span>]</span>).</p>
<h2 id="gather-works-surprisingly-well-and-matches-simple-data-structures">Gather works surprisingly well and matches simple data structures</h2>
<p>gather is a straightforward algorithm.</p>
<p>easy to take advantage of other data structures b/c “just k-mers”.</p>
<p>SBT, LCA implementations. Talk about k-mer and colro aggregative methods?</p>
<p>xx can we guess at places where gather would break?</p>
<p><code>gather</code> is a new method for decomposing datasets into its components that
outperforms current method when using synthetic datasets with known composition.
By leveraging <em>Scaled MinHash</em> sketches and efficient indexing data structures
it can scale the number of reference datasets used by over an order of magnitude when compared
to existing methods.</p>
<p>Other containment estimation methods described in Chapter <a href="#chp-scaled">1</a>,
<em>CMash</em> <span class="citation" data-cites="koslicki_improving_2019">[<span class="citeproc-not-found" data-reference-id="koslicki_improving_2019"><strong>???</strong></span>]</span> and <em>mash screen</em> <span class="citation" data-cites="ondov_mash_2019">[<span class="citeproc-not-found" data-reference-id="ondov_mash_2019"><strong>???</strong></span>]</span>,
can also implement <code>gather</code>.
<!-- David comment: "CMash does kinda, but uses unique k-mers instead of
removing matches like gather does. CMash commit
https://github.com/dkoslicki/CMash/commit/de7bdd6fa
-->
Running a search requires access to the original dataset (<em>mash screen</em>) for the query,
or a Bloom Filter derived from the original dataset (<em>CMash</em>),
and when the collection of reference sketches is updated the Bloom Filter from <em>CMash</em> can be reused,
but <em>mash screen</em> needs access to original dataset again.</p>
<p>Since <em>Scaled MinHash</em> sketches allow using the sketch directly for <code>gather</code>,
which are a fraction of the original data in size and also allow enumerating all the elements,
an operation not possible with Bloom Filters,
they can be stored and reused for large collections of sequencing datasets,
including public databases like the Sequence Read Archive <span class="citation" data-cites="leinonen_sequence_2011">[<span class="citeproc-not-found" data-reference-id="leinonen_sequence_2011"><strong>???</strong></span>]</span>.
A service that calculate these <em>Scaled MinHash</em> sketches and make them available can improve discoverability of these large collections,
as well as support future use cases derived from other <em>Scaled MinHash</em> features.</p>
<!-- Scaling to large collections of references -->
<p>Taxonomic profiling is fundamentally limited by the availability of reference datasets,
even if new reference datasets can be derived from clustering possible organisms based on sequence data in metagenomes <span class="citation" data-cites="milanese_microbial_2019">[<span class="citeproc-not-found" data-reference-id="milanese_microbial_2019"><strong>???</strong></span>]</span>.
<code>gather</code> as implemented in <code>sourmash</code> is a method that can scale to increasingly larger collections of datasets
due to multiple reasons:</p>
<ul>
<li><p>containment and similarity estimation with <em>Scaled MinHash</em> sketches has
lower computational requirements than alignment over all reads of a dataset;</p></li>
<li><p>since <em>Scaled MinHash</em> sketches use a subset of the <span class="math inline">\(k\)</span>-mer composition,
they also scale better than full <span class="math inline">\(k\)</span>-mer composition representations,
requiring less space and reducing the number of elements to be computed;</p></li>
<li><p>querying multiple databases can be done independently,
avoiding the need to merge,
update or reprocess databases when new datasets are available.
A new database with the new datasets can be constructed and queried together
with previous ones.</p></li>
</ul>
<!-- TODO to make this point I need more info about the other databases used...
I don't think they were calculated from the refseq snapshot
https://github.com/CAMI-challenge/data/issues/2
These aspects allowed the `sourmash` database to be include the largest number
of reference datasets of all methods compared,
-->
<!-- dependency on taxonomic assignments -->
<p>Taxonomic profiling in <code>sourmash</code> is implemented as an extra step on top of <code>gather</code> results.
Because these steps are independent of the dataset assignment that <code>gather</code> generates,
updates to the taxonomy don’t require re-executing <code>gather</code>,
since the taxonomic information can be derived from the same dataset identifier
(but potentially with a new associated taxonomic ID).
This allows using new taxonomies derived from the same underlying datasets <span class="citation" data-cites="parks_standardized_2018">[<span class="citeproc-not-found" data-reference-id="parks_standardized_2018"><strong>???</strong></span>]</span>,
as well as updates to the original taxonomy used before.</p>
<!-- Benchmarking -->
<p>Despite improvements to standardization and reproducibility of previous analysis,
benchmarking taxonomic profiling tools is still challenging,
since tools can generate their reference databases from multiple sources and
choosing only one source can bias or make it impossible to evaluate them properly.
This is especially true for real metagenomic datasets derived from samples
collected from soil and marine environments,
where the number of unknown organisms is frequently larger than those contained in
reference databases.
With the advent of metagenome-assembled genomes (MAGs) there are more resources
available for usage as reference datasets,
even if they are usually incomplete or draft quality.
<code>sourmash</code> is well positioned to include these new references to taxonomic
profiling given the minimal requirements (a <em>Scaled MinHash</em> sketch of the
original dataset) and support for indexing hundreds of thousands of datasets.</p>
<h3 id="limitations-of-gather">Limitations of gather</h3>
<p><code>gather</code> as implemented in <code>sourmash</code> has the same limitations as <em>Scaled MinHash</em> sketches,
including reduced sensitivity to small genomes/sequences such as viruses.
<em>Scaled MinHash</em> sketches don’t preserve information about individual sequences,
and short sequences using large scaled values have increasingly smaller chances of having any of its
<span class="math inline">\(k\)</span>-mers (represented as hashes) contained in the sketch.
Because it favors the best containment,
larger genomes are also more likely to be chosen first due to their sketches have more elements,
and further improvements can take the size of the match in consideration too.
Note that this is not necessarily the <em>similarity</em> <span class="math inline">\(J(A, B)\)</span> (which takes the size of both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>),
but a different calculation that normalizes the containment considering the size of the match.</p>
<p><code>gather</code> is also a greedy algorithm,
choosing the best containment match at each step.
Situations where multiple matches are equally well contained or many datasets
are very similar to each other can complicate this approach,
and additional steps must be taken to disambiguate matches.
The availability of abundance counts for each element in the <em>Scaled MinHash</em> is not well explored,
since the process of <em>removing elements</em> from the query doesn’t account for them
(the element is removed even if the count is much higher than the count in the match).
<!-- David comment: could use a compressive sensing approach here:
$ min \norm{x}^2_1 + \lambda \norm{Ax - y}^2_2, x \ge 0$
Y_i = count of hash i in sample
A_ij = count of hash i in genome j
convert to least squares and use Lawson and Hanson for blistering speed!
-->
Both the multiple match as well as the abundance counts issues can benefit from
existing solutions taken by other methods,
like the <em>species score</em> (for disambiguation) and <em>Expectation-Maximization</em> (for abundance analysis)
approaches from Centrifuge <span class="citation" data-cites="kim_centrifuge_2016">[<span class="citeproc-not-found" data-reference-id="kim_centrifuge_2016"><strong>???</strong></span>]</span>.</p>
<h3 id="future-directions">Future directions</h3>
<p>In this chapter <code>gather</code> is described in terms of taxonomic profiling of metagenomes.
That is one application of the algorithm,
but it can applied to other biological problems too.
If the query is a genome instead of a metagenome,
<code>gather</code> can be used to detect possible contamination in the assembled genome by
using a collection of genomes and removing the query genome from it (if it is present).
This allows finding matches that contain the query genome and evaluating if they agree at specific taxonomic rank,
and in case of large divergence (two different phyla are found, for example)
it is likely to indicative that the query genome contains sequences from different organisms.
This is especially useful for quality control and validation of metagenome-assembled genomes (MAGs),
genomes assembled from reads binned and clustered from metagenomes,
as well as a verification during submission of new assembled genomes to public
genomic databases like GenBank.</p>
<p>Improvements to the calculation of <em>Scaled MinHash</em> sketches can also improve
the taxonomic profiling use case.
Exact <span class="math inline">\(k\)</span>-mer matching is limited in phylogenetically distant organisms,
since small nucleotide differences lead to distinct <span class="math inline">\(k\)</span>-mers,
breaking homology assumptions. <!-- TODO verify/cite? -->
Different approaches for converting the datasets into a set to be hashed (<em>shingling</em>) than computing the nucleotide <span class="math inline">\(k\)</span>-mer composition,
such as spaced <span class="math inline">\(k\)</span>-mers <span class="citation" data-cites="leimeister_fast_2014">[<span class="citeproc-not-found" data-reference-id="leimeister_fast_2014"><strong>???</strong></span>]</span> and minimizers <span class="citation" data-cites="roberts_reducing_2004">[<span class="citeproc-not-found" data-reference-id="roberts_reducing_2004"><strong>???</strong></span>]</span>
and alternative encodings for the nucleotides using 6-frame translation to amino acid <span class="citation" data-cites="gish_identification_1993">[<span class="citeproc-not-found" data-reference-id="gish_identification_1993"><strong>???</strong></span>]</span>
or other reduced alphabets <span class="citation" data-cites="peterson_reduced_2009">[<span class="citeproc-not-found" data-reference-id="peterson_reduced_2009"><strong>???</strong></span>]</span>,
can allow comparisons on longer evolutionary distances and so improve taxonomic profiling by increasing the sensitivity of the containment estimation.
These improvements don’t fundamentally change the <code>gather</code> method,
since it would still be based on the same <em>containment</em> and <em>remove element</em> operations,
but show how <code>gather</code> works as a more general method that can leverage characteristics from different building blocks and explore new or improved use cases.</p>
<p><code>gather</code> is a new method for decomposing datasets into its components with
application in biological sequencing data analysis (taxonomic profiling) that
can scale to hundreds of thousands of reference datasets with computational
resources requirements that are accessible to a large number of users
when used in conjunction with <em>Scaled MinHash</em> sketches and efficient indices
such as <em>LCA</em> and <em>MHBT</em>.
It outperforms current methods in community-develop benchmarks,
and opens the way for new methods that explore a top-down approach for profiling
microbial communities,
including further refinements that can resolve larger evolutionary distances and
also speed up the method computationally.</p>
<h2 id="xxx-sbt-and-lca-indices">XXX SBT and LCA indices</h2>
<h3 id="limitations-and-future-directions">Limitations and future directions</h3>
<p><em>Scaled MinHash</em> sketches are fundamentally a subset of the <span class="math inline">\(k\)</span>-mer composition of a dataset,
and so any of the techniques described in <span class="citation" data-cites="marchet_data_2019">[<span class="citeproc-not-found" data-reference-id="marchet_data_2019"><strong>???</strong></span>]</span> are potential
candidates for improving current indices or implementing new ones.
The MHBT index can be improved by using more efficient representations for the internal nodes <span class="citation" data-cites="solomon_improved_2017">[<span class="citeproc-not-found" data-reference-id="solomon_improved_2017"><strong>???</strong></span>]</span>
and constructing the MHBT by clustering <span class="citation" data-cites="harris_improved_2018">[<span class="citeproc-not-found" data-reference-id="harris_improved_2018"><strong>???</strong></span>]</span>,
and the LCA index can use more efficient storage of the list of signatures IDs by representing the list as colors <span class="citation" data-cites="pandey_mantis:_2018">[<span class="citeproc-not-found" data-reference-id="pandey_mantis:_2018"><strong>???</strong></span>]</span>.
The memory consumption of the LCA index can also be tackled by implementing it in
external memory using memory-mapped files,
letting the operating system cache and unload pages as needed.</p>
<p>Current indices are also single-threaded,
and don’t benefit from multicore systems.
Both indices can be used in parallel by loading as read-only and sharing for multiple searches,
but is is also possible to explore parallelization for single queries by
partitioning the LCA and assigning each partition to a thread,
as well as using a work-stealing thread pool for expanding the search frontier in the MHBT in parallel.
In any case,
the current implementations serve as a baseline for future scalability and can
be used to guide optimization and avoid extraneous overhead and common failings
of such projects <span class="citation" data-cites="mcsherry_scalability_2015">[<span class="citeproc-not-found" data-reference-id="mcsherry_scalability_2015"><strong>???</strong></span>]</span>.</p>
<h2 id="conclusion">Conclusion</h2>
<p><em>Scaled MinHash</em> sketches allow scaling analysis to thousands of datasets,
but efficiently searching and sharing them can benefit from data structures that
index and optimize these use cases.
This chapter introduces an index abstraction that can be trivially implementing
using a list of sketches (<em>Linear index</em>) and more advanced implementations
based on inverted indices (<em>LCA index</em>) and hierarchical indices (<em>MHBT</em>)
providing options for fast and memory-efficient operations,
as well as making it easier to share and analyze collections of sketches.
All these functionalities are implemented in</p>
<h2 id="taxonomy-results-are-excellent.">Taxonomy results are excellent.</h2>
<p>Discuss vs LCA.</p>
<p>reference the LCA-has-limits/k-mers saturate paper</p>
<p>mix and match taxonomies is easy b/c we anchor to genomes.</p>
<h2 id="algorithm-is-simple-computational-performance-is-great">Algorithm is simple, computational performance is great</h2>
<p>Performant implementation in sourmasha Python API for data exploration and methods prototyping.</p>
<h2 id="database-types-work-well">Database types work well</h2>
<p>“online” approaches</p>
<p>Some limitations of gather and database types (equal results can be hard to detect efficiently with current SBT implementation)</p>
<p>The Linear index is appropriate for operations that must check every signature,
since it doesn’t have any indexing overhead.
An example is building a distance matrix for comparing signatures all-against-all.
Search operations greatly benefit from extra indexing structure.
The MHBT index and <span class="math inline">\(k\)</span>-mer aggregative methods in general are appropriate for searches with query thresholds,
like searching for similarity or containment of a query in a collection of datasets.
The LCA index and color aggregative methods are appropriate for querying which datasets contain a specific query <span class="math inline">\(k\)</span>-mer.</p>
<p>As implemented in sourmash,
the MHBT index is more memory efficient because the data can stay in external memory and only the tree structure for the index
need to be loaded in main memory,
and data for the datasets and internal nodes can be loaded and unloaded on demand.
The LCA index must be loaded in main memory before it can be used,
but once it is loaded it is faster,
especially for operations that need to summarize <span class="math inline">\(k\)</span>-mer assignments or require repeated searches.</p>
<p>Due to these characteristics,
and if memory usage is not a concern,
then the LCA index is the most appropriate choice since it is faster.
The MHBT index is currently recommended for situations where memory is limited,
such as with smaller scaled values (<span class="math inline">\(s\le2000\)</span>)
that increase the size of signatures,
or when there are a large number (hundreds of thousands or more) of datasets to index.</p>
<h3 id="converting-between-indices">Converting between indices</h3>
<p>Both MHBT and LCA index can recover the original sketch collection.
In the MHBT case,
it outputs all the leaf nodes.
In the LCA index,
it reconstruct each sketch from the hash-to-dataset-ID mapping.
This allows trade-offs between storage efficiency,
distribution,
updating and query performance.</p>
<p>Because both are able to return the original sketch collection,
it is also possible to convert one index into the other.</p>
<h3 id="limitations-and-future-directions-1">Limitations and future directions</h3>
<p>From David Koslicki:</p>
<p>In my initial investigation/calculations, it appears that the gotchas are things you’re aware of:
Lack of sensitivity for small queries
Potentially large sketch sizes
And a couple other that I’ve tentatively/mathematically observed:
The variance of the estimate of C(A,B)=|AB| / |A| appears to also depend on |A|, which was somewhat surprising
The “fixed k-size” problem (which might be able to be overcome with the prefix-lookup data structure, if one sacrifices some accuracy)</p>
<p><em>Scaled MinHash</em> sketches are fundamentally a subset of the <span class="math inline">\(k\)</span>-mer composition of a dataset,
and so any of the techniques described in <span class="citation" data-cites="marchet_data_2019">[<span class="citeproc-not-found" data-reference-id="marchet_data_2019"><strong>???</strong></span>]</span> are potential
candidates for improving current indices or implementing new ones.
The MHBT index can be improved by using more efficient representations for the internal nodes <span class="citation" data-cites="solomon_improved_2017">[<span class="citeproc-not-found" data-reference-id="solomon_improved_2017"><strong>???</strong></span>]</span>
and constructing the MHBT by clustering <span class="citation" data-cites="harris_improved_2018">[<span class="citeproc-not-found" data-reference-id="harris_improved_2018"><strong>???</strong></span>]</span>,
and the LCA index can use more efficient storage of the list of signatures IDs by representing the list as colors <span class="citation" data-cites="pandey_mantis:_2018">[<span class="citeproc-not-found" data-reference-id="pandey_mantis:_2018"><strong>???</strong></span>]</span>.
The memory consumption of the LCA index can also be tackled by implementing it in
external memory using memory-mapped files,
letting the operating system cache and unload pages as needed.</p>
<p>Current indices are also single-threaded,
and don’t benefit from multicore systems.
Both indices can be used in parallel by loading as read-only and sharing for multiple searches,
but is is also possible to explore parallelization for single queries by
partitioning the LCA and assigning each partition to a thread,
as well as using a work-stealing thread pool for expanding the search frontier in the MHBT in parallel.
In any case,
the current implementations serve as a baseline for future scalability and can
be used to guide optimization and avoid extraneous overhead and common failings
of such projects <span class="citation" data-cites="mcsherry_scalability_2015">[<span class="citeproc-not-found" data-reference-id="mcsherry_scalability_2015"><strong>???</strong></span>]</span>.</p>
<p><em>Scaled MinHash</em> sketches allow scaling analysis to thousands of datasets,
but efficiently searching and sharing them can benefit from data structures that
index and optimize these use cases.
This chapter introduces an index abstraction that can be trivially implementing
using a list of sketches (<em>Linear index</em>) and more advanced implementations
based on inverted indices (<em>LCA index</em>) and hierarchical indices (<em>MHBT</em>)
providing options for fast and memory-efficient operations,
as well as making it easier to share and analyze collections of sketches.
All these functionalities are implemented in <code>sourmash</code>,
a software package exposing these features as a command-line program as well as
a Python API for data exploration and methods prototyping.</p>
<p>These indices also serve as another set of building blocks for constructing more advanced
methods for solving other relevant biological problems like taxonomic profiling,
described in Chapter <a href="#chp-gather">3</a>,
and approaches for increasing the resilience and shareability of biological
sequencing data,
described in Chapter <a href="#chp-decentralizing">5</a>.</p>
<h2 id="scaled-minhash-has-limitations-vs-regular-minhash">Scaled minhash has limitations vs regular minhash</h2>
<p>virus, etc. (could go in first discussion section, but also deserves to be highlighted)</p>
<h1 id="conclusion-1">Conclusion</h1>
<p><em>Scaled MinHash</em> sketches are simple to implement and analyze,
with consistent guarantees for the range of values and subsetting properties when
applied to datasets.
Containment and similarity operations between <em>Scaled MinHash</em> sketches
avoid the need to access the original data or more limited representations that only allow membership query,
and serve as a proxy for large scale comparisons between hundreds or thousands of datasets.</p>
<p>Small genomes require low scaled values in order to properly estimate containment and similarity,
and exact <span class="math inline">\(k\)</span>-mer matching is brittle when considering evolutionarily-diverged organisms.
While some of these problems can be overcome in future work,
<em>Scaled MinHash</em> sketches can serve as a prefilter for more accurate and
computationally expensive applications,
allowing these methods to be used in larger scales by avoiding processing data
that is unlikely to return usable results.</p>
<p><em>Scaled MinHash</em> sketches are effective basic building blocks for creating a software
ecosystem that allow practical applications,
including taxonomic classification in metagenomes and large scale indexing and searching in public genomic databases.</p>
<h2 class="page_break_before" id="references">References</h2>
<!-- Explicitly insert bibliography here -->
<div id="refs" role="doc-bibliography">

</div>
<!-- default theme -->

<style>
    /* import google fonts */
    @import url("https://fonts.googleapis.com/css?family=Open+Sans:400,600,700");
    @import url("https://fonts.googleapis.com/css?family=Source+Code+Pro");

    /* -------------------------------------------------- */
    /* global */
    /* -------------------------------------------------- */

    /* all elements */
    * {
        /* force sans-serif font unless specified otherwise */
        font-family: "Open Sans", "Helvetica", sans-serif;

        /* prevent text inflation on some mobile browsers */
        -webkit-text-size-adjust: none !important;
        -moz-text-size-adjust: none !important;
        -o-text-size-adjust: none !important;
        text-size-adjust: none !important;
    }

    @media only screen {
        /* "page" element */
        body {
            position: relative;
            box-sizing: border-box;
            font-size: 12pt;
            line-height: 1.5;
            max-width: 8.5in;
            margin: 20px auto;
            padding: 40px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* "page" element */
        body {
            padding: 20px;
            margin: 0;
            border-radius: 0;
            border: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05) inset;
            background: none;
        }
    }

    /* -------------------------------------------------- */
    /* headings */
    /* -------------------------------------------------- */

    /* all headings */
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        margin: 20px 0;
        padding: 0;
        font-weight: bold;
    }

    /* biggest heading */
    h1 {
        margin: 40px 0;
        text-align: center;
    }

    /* second biggest heading */
    h2 {
        margin-top: 30px;
        padding-bottom: 5px;
        border-bottom: solid 1px #bdbdbd;
    }

    /* heading font sizes */
    h1 {
        font-size: 2em;
    }
    h2 {
        font-size: 1.5em;
    }
    h3{
        font-size: 1.35em;
    }
    h4 {
        font-size: 1.25em;
    }
    h5 {
        font-size: 1.15em;
    }
    h6 {
        font-size: 1em;
    }

    /* -------------------------------------------------- */
    /* manuscript header */
    /* -------------------------------------------------- */

    /* manuscript title */
    header > h1 {
        margin: 0;
    }

    /* manuscript title caption text (ie "automatically generated on") */
    header + p {
        text-align: center;
        margin-top: 10px;
    }

    /* -------------------------------------------------- */
    /* text elements */
    /* -------------------------------------------------- */

    /* links */
    a {
        color: #2196f3;
        overflow-wrap: break-word;
    }

    /* normal links (not empty, not button link, not syntax highlighting link) */
    a:not(:empty):not(.button):not(.sourceLine) {
        padding-left: 1px;
        padding-right: 1px;
    }

    /* superscripts and subscripts */
    sub,
    sup {
        /* prevent from affecting line height */
        line-height: 0;
    }

    /* unordered and ordered lists*/
    ul,
    ol {
        padding-left: 20px;
    }

    /* class for styling text semibold */
    .semibold {
        font-weight: 600;
    }

    /* class for styling elements horizontally left aligned */
    .left {
        display: block;
        text-align: left;
        margin-left: auto;
        margin-right: 0;
        justify-content: left;
    }

    /* class for styling elements horizontally centered */
    .center {
        display: block;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
        justify-content: center;
    }

    /* class for styling elements horizontally right aligned */
    .right {
        display: block;
        text-align: right;
        margin-left: 0;
        margin-right: auto;
        justify-content: right;
    }

    /* -------------------------------------------------- */
    /* section elements */
    /* -------------------------------------------------- */

    /* horizontal divider line */
    hr {
        border: none;
        height: 1px;
        background: #bdbdbd;
    }

    /* paragraphs, horizontal dividers, figures, tables, code */
    p,
    hr,
    figure,
    table,
    pre {
        /* treat all as "paragraphs", with consistent vertical margins */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* figures */
    /* -------------------------------------------------- */

    /* figure */
    figure {
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure caption */
    figcaption {
        padding: 0;
        padding-top: 10px;
    }

    /* figure image element */
    figure img {
        max-width: 100%;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }

    /* figure auto-number */
    img + figcaption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* tables */
    /* -------------------------------------------------- */

    /* table */
    table {
        border-collapse: collapse;
        border-spacing: 0;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
    }

    /* table cells */
    th,
    td {
        border: solid 1px #bdbdbd;
        padding: 10px;
        /* squash table if too wide for page by forcing line breaks */
        overflow-wrap: break-word;
        word-break: break-word;
    }

    /* header row and even rows */
    th,
    tr:nth-child(2n) {
        background-color: #fafafa;
    }

    /* odd rows */
    tr:nth-child(2n + 1) {
        background-color: #ffffff;
    }

    /* table caption */
    caption {
        text-align: left;
        padding: 0;
        padding-bottom: 10px;
    }

    /* table auto-number */
    table > caption > span:first-of-type,
    div.table_wrapper > table > caption > span:first-of-type {
        font-weight: bold;
        margin-right: 5px;
    }

    /* -------------------------------------------------- */
    /* code */
    /* -------------------------------------------------- */

    /* multi-line code block */
    pre {
        padding: 10px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
        break-inside: avoid;
        text-align: left;
    }

    /* inline code, ie code within normal text */
    :not(pre) > code {
        padding: 0 4px;
        background-color: #eeeeee;
        color: #000000;
        border-radius: 5px;
    }

    /* code text */
    /* apply all children, to reach syntax highlighting sub-elements */
    code,
    code * {
        /* force monospace font */
        font-family: "Source Code Pro", "Courier New", monospace;
    }

    /* -------------------------------------------------- */
    /* quotes */
    /* -------------------------------------------------- */

    /* quoted text */
    blockquote {
        margin: 0;
        padding: 0;
        border-left: 4px solid #bdbdbd;
        padding-left: 16px;
        break-inside: avoid;
    }

    /* -------------------------------------------------- */
    /* banners */
    /* -------------------------------------------------- */

    /* info banners */
    .banner {
        box-sizing: border-box;
        display: block;
        position: relative;
        width: 100%;
        margin-top: 20px;
        margin-bottom: 20px;
        padding: 20px;
        text-align: center;
    }

    /* paragraph in banner */
    .banner > p {
        margin: 0;
    }

    /* -------------------------------------------------- */
    /* highlight colors */
    /* -------------------------------------------------- */

    .white {
        background: #ffffff;
    }
    .lightgrey {
        background: #eeeeee;
    }
    .grey {
        background: #757575;
    }
    .darkgrey {
        background: #424242;
    }
    .black {
        background: #000000;
    }
    .lightred {
        background: #ffcdd2;
    }
    .lightyellow {
        background: #ffecb3;
    }
    .lightgreen {
        background: #dcedc8;
    }
    .lightblue {
        background: #e3f2fd;
    }
    .lightpurple {
        background: #f3e5f5;
    }
    .red {
        background: #f44336;
    }
    .orange {
        background: #ff9800;
    }
    .yellow {
        background: #ffeb3b;
    }
    .green {
        background: #4caf50;
    }
    .blue {
        background: #2196f3;
    }
    .purple {
        background: #9c27b0;
    }
    .white,
    .lightgrey,
    .lightred,
    .lightyellow,
    .lightgreen,
    .lightblue,
    .lightpurple,
    .orange,
    .yellow,
    .white a,
    .lightgrey a,
    .lightred a,
    .lightyellow a,
    .lightgreen a,
    .lightblue a,
    .lightpurple a,
    .orange a,
    .yellow a {
        color: #000000;
    }
    .grey,
    .darkgrey,
    .black,
    .red,
    .green,
    .blue,
    .purple,
    .grey a,
    .darkgrey a,
    .black a,
    .red a,
    .green a,
    .blue a,
    .purple a {
        color: #ffffff;
    }

    /* -------------------------------------------------- */
    /* buttons */
    /* -------------------------------------------------- */

    /* class for styling links like buttons */
    .button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        margin: 5px;
        padding: 10px 20px;
        font-size: 0.75em;
        font-weight: 600;
        text-transform: uppercase;
        text-decoration: none;
        letter-spacing: 1px;
        background: none;
        color: #2196f3;
        border: solid 1px #bdbdbd;
        border-radius: 5px;
    }

    /* buttons when hovered */
    .button:hover:not([disabled]),
    .icon_button:hover:not([disabled]) {
        cursor: pointer;
        background: #f5f5f5;
    }

    /* buttons when disabled */
    .button[disabled],
    .icon_button[disabled] {
        opacity: 0.35;
        pointer-events: none;
    }

    /* class for styling buttons containg only single icon */
    .icon_button {
        display: inline-flex;
        justify-content: center;
        align-items: center;
        text-decoration: none;
        margin: 0;
        padding: 0;
        background: none;
        border-radius: 5px;
        border: none;
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
    }

    /* icon button inner svg image */
    .icon_button > svg {
        height: 16px;
    }

    /* -------------------------------------------------- */
    /* icons */
    /* -------------------------------------------------- */

    /* class for styling icons inline with text */
    .inline_icon {
        height: 1em;
        position: relative;
        top: 0.125em;
    }

    /* -------------------------------------------------- */
    /* print control */
    /* -------------------------------------------------- */

    @media print {
        @page {
            /* suggested printing margin */
            margin: 0.5in;
        }

        /* document and "page" elements */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        /* "page" element */
        body {
            font-size: 11pt !important;
            line-height: 1.35;
        }

        /* all headings */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            margin: 15px 0;
        }

        /* figures and tables */
        figure, table {
            font-size: 0.85em;
        }

        /* table cells */
        th,
        td {
            padding: 5px;
        }

        /* shrink font awesome icons */
        i.fas,
        i.fab,
        i.far,
        i.fal {
            transform: scale(0.85);
        }

        /* decrease banner margins */
        .banner {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 15px;
        }

        /* class for centering an element vertically on its own page */
        .page_center {
            margin: auto;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            vertical-align: middle;
            break-before: page;
            break-after: page;
        }

        /* always insert a page break before the element */
        .page_break_before {
            break-before: page;
        }

        /* always insert a page break after the element */
        .page_break_after {
            break-after: page;
        }

        /* avoid page break before the element */
        .page_break_before_avoid {
            break-before: avoid;
        }

        /* avoid page break after the element */
        .page_break_after_avoid {
            break-after: avoid;
        }

        /* avoid page break inside the element */
        .page_break_inside_avoid {
            break-inside: avoid;
        }
    }

    /* -------------------------------------------------- */
    /* override pandoc css quirks */
    /* -------------------------------------------------- */

    .sourceCode {
        /* prevent unsightly overflow in wide code blocks */
        overflow: auto !important;
    }

    div.sourceCode {
        /* prevent background fill on top-most code block  container */
        background: none !important;
    }

    .sourceCode * {
        /* force consistent line spacing */
        line-height: 1.5 !important;
    }

    div.sourceCode {
        /* style code block margins same as <pre> element */
        margin-top: 20px;
        margin-bottom: 20px;
    }

    /* -------------------------------------------------- */
    /* tablenos */
    /* -------------------------------------------------- */

    /* tablenos wrapper */
    .tablenos {
        /* show scrollbar on tables if necessary to prevent overflow */
        width: 100%;
        margin: 20px 0;
    }

    .tablenos > table {
        /* move margins from table to table_wrapper to allow margin collapsing */
        margin: 0;
    }

    @media only screen {
        /* tablenos wrapper */
        .tablenos {
            /* show scrollbar on tables if necessary to prevent overflow */
            overflow-x: auto !important;
        }

        .tablenos th,
        .tablenos td {
            overflow-wrap: unset !important;
            word-break: unset !important;
        }

        /* table in wrapper */
        .tablenos table,
        .tablenos table * {
            /* don't break table words */
            overflow-wrap: normal !important;
        }
    }

    /* -------------------------------------------------- */
    /* mathjax */
    /* -------------------------------------------------- */

    /* mathjax containers */
    .math.display > span:not(.MathJax_Preview) {
        /* turn inline element (no dimensions) into block (allows fixed width and thus scrolling) */
        display: flex !important;
        overflow-x: auto !important;
        overflow-y: hidden !important;
        justify-content: center;
        align-items: center;
        margin: 0 !important;
    }

    /* right click menu */
    .MathJax_Menu {
        border-radius: 5px !important;
        border: solid 1px #bdbdbd !important;
        box-shadow: none !important;
    }

    /* equation auto-number */
    span[id^="eq:"] > span.math.display + span {
        font-weight: 600;
    }

    /* equation */
    span[id^="eq:"] > span.math.display > span {
        /* nudge to make room for equation auto-number and anchor */
        margin-right: 60px !important;
    }

    /* -------------------------------------------------- */
    /* anchors plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anchor button */
        .anchor {
            opacity: 0;
            margin-left: 5px;
        }

        /* anchor buttons within <h2>'s */
        h2 .anchor {
            margin-left: 10px;
        }

        /* anchor buttons when hovered/focused and anything containing an anchor button when hovered */
        *:hover > .anchor,
        .anchor:hover,
        .anchor:focus {
            opacity: 1;
        }

        /* anchor button when hovered */
        .anchor:hover {
            cursor: pointer;
        }
    }

    /* always show anchor button on devices with no mouse/hover ability */
    @media (hover: none) {
        .anchor {
            opacity: 1;
        }
    }

    /* always hide anchor button on print */
    @media only print {
        .anchor {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* accordion plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* accordion arrow button */
        .accordion_arrow {
            margin-right: 10px;
        }

        /* arrow icon when <h2> data-collapsed attribute true */
        h2[data-collapsed="true"] > .accordion_arrow > svg {
            transform: rotate(-90deg);
        }

        /* all elements (except <h2>'s) when data-collapsed attribute true */
        *:not(h2)[data-collapsed="true"] {
            display: none;
        }

        /* accordion arrow button when hovered and <h2>'s when hovered */
        .accordion_arrow:hover,
        h2[data-collapsed="true"]:hover,
        h2[data-collapsed="false"]:hover {
            cursor: pointer;
        }
    }

    /* always hide accordion arrow button on print */
    @media only print {
        .accordion_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* tooltips plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* tooltip container */
        #tooltip {
            position: absolute;
            width: 50%;
            min-width: 240px;
            max-width: 75%;
            z-index: 1;
        }

        /* tooltip content */
        #tooltip_content {
            margin-bottom: 5px;
            padding: 20px;
            border-radius: 5px;
            border: solid 1px #bdbdbd;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            background: #ffffff;
            overflow-wrap: break-word;
        }

        /* tooltip copy of paragraphs and figures */
        #tooltip_content > p,
        #tooltip_content > figure {
            margin: 0;
            max-height: 320px;
            overflow-y: auto;
        }

        /* tooltip copy of <img> */
        #tooltip_content > figure > img {
            max-height: 260px;
        }

        /* navigation bar */
        #tooltip_nav_bar {
            margin-top: 10px;
            text-align: center;
        }

        /* navigation bar previous/next buton */
        #tooltip_nav_bar > .icon_button {
            position: relative;
            top: 3px;
        }

        /* navigation bar previous button */
        #tooltip_nav_bar > .icon_button:first-of-type {
            margin-right: 5px;
        }

        /* navigation bar next button */
        #tooltip_nav_bar > .icon_button:last-of-type {
            margin-left: 5px;
        }
    }

    /* always hide tooltip on print */
    @media only print {
        #tooltip {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* jump to first plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* jump button */
        .jump_arrow {
            position: relative;
            top: 0.125em;
            margin-right: 5px;
        }
    }

    /* always hide jump button on print */
    @media only print {
        .jump_arrow {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* link highlight plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* anything with data-highlighted attribute true */
        [data-highlighted="true"] {
            background: #ffeb3b;
        }

        /* anything with data-selected attribute true */
        [data-selected="true"] {
            background: #ff8a65 !important;
        }

        /* animation definition for glow */
        @keyframes highlight_glow {
            0% {
                background: none;
            }
            10% {
                background: #bbdefb;
            }
            100% {
                background: none;
            }
        }

        /* anything with data-glow attribute true */
        [data-glow="true"] {
            animation: highlight_glow 2s;
        }
    }

    /* -------------------------------------------------- */
    /* table of contents plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* toc panel */
        #toc_panel {
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            background: #ffffff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            z-index: 2;
        }

        /* toc panel when closed */
        #toc_panel[data-open="false"] {
            min-width: 60px;
            width: 60px;
            height: 60px;
            border-right: solid 1px #bdbdbd;
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc panel when open */
        #toc_panel[data-open="true"] {
            min-width: 260px;
            max-width: 480px;
            /* keep panel edge consistent distance away from "page" edge */
            width: calc(((100vw - 8.5in) / 2) - 30px - 40px);
            bottom: 0;
            border-right: solid 1px #bdbdbd;
        }

        /* toc panel header */
        #toc_header {
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: center;
            height: 60px;
            margin: 0;
            padding: 20px;
        }

        /* toc panel header when hovered */
        #toc_header:hover {
            cursor: pointer;
        }

        /* toc panel header when panel open */
        #toc_panel[data-open="true"] > #toc_header {
            border-bottom: solid 1px #bdbdbd;
        }

        /* toc open/close header button */
        #toc_button {
            margin-right: 20px;
        }

        /* hide toc list and header text when closed */
        #toc_panel[data-open="false"] > #toc_header > *:not(#toc_button),
        #toc_panel[data-open="false"] > #toc_list {
            display: none;
        }

        /* toc list of entries */
        #toc_list {
            box-sizing: border-box;
            width: 100%;
            padding: 20px;
            position: absolute;
            top: calc(60px + 1px);
            bottom: 0;
            overflow: auto;
        }

        /* toc entry, link to section in document */
        .toc_link {
            display: block;
            padding: 5px;
            position: relative;
            font-weight: 600;
            text-decoration: none;
        }

        /* toc entry when hovered or when "viewed" */
        .toc_link:hover,
        .toc_link[data-viewing="true"] {
            background: #f5f5f5;
        }

        /* toc entry, level 1 indentation */
        .toc_link[data-level="1"] {
            margin-left: 0;
        }

        /* toc entry, level 2 indentation */
        .toc_link[data-level="2"] {
            margin-left: 20px;
        }

        /* toc entry, level 3 indentation */
        .toc_link[data-level="3"] {
            margin-left: 40px;
        }

        /* toc entry, level 4 indentation */
        .toc_link[data-level="4"] {
            margin-left: 60px;
        }

        /* toc entry bullets */
        #toc_panel[data-bullets="true"] .toc_link[data-level]:before {
            position: absolute;
            left: -15px;
            top: -1px;
            font-size: 1.5em;
        }

        /* toc entry, level 2 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="2"]:before {
            content: "\2022";
        }

        /* toc entry, level 3 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="3"]:before {
            content: "\25AB";
        }

        /* toc entry, level 4 bullet */
        #toc_panel[data-bullets="true"] .toc_link[data-level="4"]:before {
            content: "-";
        }
    }

    /* when on screen < 8.5in wide */
    @media only screen and (max-width: 8.5in) {
        /* push <body> ("page") element down to make room for toc icon */
        .toc_body_nudge {
            padding-top: 60px;
        }

        /* toc icon when panel closed and not hovered */
        #toc_panel[data-open="false"]:not(:hover) {
            background: rgba(255, 255, 255, 0.75);
        }
    }

    /* always hide toc panel on print */
    @media only print {
        #toc_panel {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* lightbox plugin */
    /* -------------------------------------------------- */

    @media only screen {
        /* regular <img> in document when hovered */
        .lightbox_document_img:hover {
            cursor: pointer;
        }

        .body_no_scroll {
            overflow: hidden !important;
        }

        /* screen overlay */
        #lightbox_overlay {
            display: flex;
            flex-direction: column;
            position: fixed;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 3;
        }

        /* middle area containing lightbox image */
        #lightbox_image_container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 20px;
        }

        /* bottom area containing caption */
        #lightbox_bottom_container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            min-height: 100px;
            max-height: 100px;
            background: rgba(0, 0, 0, 0.5);
        }

        /* image number info text box */
        #lightbox_number_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            left: 2px;
            top: 0;
            z-index: 4;
        }

        /* zoom info text box */
        #lightbox_zoom_info {
            position: absolute;
            color: #ffffff;
            font-weight: 600;
            right: 2px;
            top: 0;
            z-index: 4;
        }

        /* copy of image caption */
        #lightbox_caption {
            box-sizing: border-box;
            display: inline-block;
            width: 100%;
            max-height: 100%;
            padding: 10px 0;
            text-align: center;
            overflow-y: auto;
            color: #ffffff;
        }

        /* navigation previous/next button */
        .lightbox_button {
            width: 100px;
            height: 100%;
            min-width: 100px;
            min-height: 100%;
            color: #ffffff;
        }

        /* navigation previous/next button when hovered */
        .lightbox_button:hover {
            background: none !important;
        }

        /* navigation button icon */
        .lightbox_button > svg {
            height: 25px;
        }

        /* figure auto-number */
        #lightbox_caption > span:first-of-type {
            font-weight: bold;
            margin-right: 5px;
        }

        /* lightbox image when hovered */
        #lightbox_img:hover {
            cursor: grab;
        }

        /* lightbox image when grabbed */
        #lightbox_img:active {
            cursor: grabbing;
        }
    }

    /* when on screen < 480px wide */
    @media only screen and (max-width: 480px) {
        /* make navigation buttons skinnier on small screens to make more room for caption text */
        .lightbox_button {
            width: 50px;
            min-width: 50px;
        }
    }

    /* always hide lightbox on print */
    @media only print {
        #lightbox_overlay {
            display: none;
        }
    }

    /* -------------------------------------------------- */
    /* hypothesis (annotations) plugin */
    /* -------------------------------------------------- */

    /* hypothesis activation button */
    #hypothesis_button {
        box-sizing: border-box;
        position: fixed;
        top: 0;
        right: 0;
        width: 60px;
        height: 60px;
        background: #ffffff;
        border-radius: 0;
        border-left: solid 1px #bdbdbd;
        border-bottom: solid 1px #bdbdbd;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
        z-index: 2;
    }

    /* hypothesis button svg */
    #hypothesis_button > svg {
        position: relative;
        top: -4px;
    }

    /* hypothesis annotation count */
    #hypothesis_count {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 5px;
    }

    /* side panel */
    .annotator-frame {
        width: 280px !important;
    }

    /* match highlight color to rest of theme */
    .annotator-highlights-always-on .annotator-hl {
        background-color: #ffeb3b !important;
    }

    /* match focused color to rest of theme */
    .annotator-hl.annotator-hl-focused {
        background-color: #ff8a65 !important;
    }

    /* match bucket bar color to rest of theme */
    .annotator-bucket-bar {
        background: #f5f5f5 !important;
    }

    /* always hide button, toolbar, and tooltip on print */
    @media only print {
        #hypothesis_button {
            display: none;
        }

        .annotator-frame {
            display: none !important;
        }

        hypothesis-adder {
            display: none !important;
        }
    }
</style>
<!-- anchors plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds an anchor next to each of a certain type
        // of element that provides a human-readable url to that specific
        // item/position in the document (eg "manuscript.html#abstract"). It
        // also makes it such that scrolling out of view of a target removes
        // its identifier from the url.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'anchors';

        // default plugin options
        const options = {
            // which types of elements to add anchors next to, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3, [id^="fig:"], [id^="tbl:"], [id^="eq:"]',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // add anchor to each element of specified types
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements)
                addAnchor(element);

            // attach scroll listener to window
            window.addEventListener('scroll', onScroll);
        }

        // when window is scrolled
        function onScroll() {
            // if url has hash and user has scrolled out of view of hash
            // target, remove hash from url
            const tolerance = 100;
            const target = getHashTarget();
            if (target) {
                if (
                    target.getBoundingClientRect().top >
                        window.innerHeight + tolerance ||
                    target.getBoundingClientRect().bottom < 0 - tolerance
                )
                    history.pushState(null, null, ' ');
            }
        }

        // add anchor to element
        function addAnchor(element) {
            let addTo; // element to add anchor button to

            // if figure or table, modify withId and addTo to get expected
            // elements
            if (element.id.indexOf('fig:') === 0) {
                addTo = element.querySelector('figcaption');
            } else if (element.id.indexOf('tbl:') === 0) {
                addTo = element.querySelector('caption');
            } else if (element.id.indexOf('eq:') === 0) {
                addTo = element.querySelector('.eqnos-number');
            }

            addTo = addTo || element;
            const id = element.id || null;

            // do not add anchor if element doesn't have assigned id.
            // id is generated by pandoc and is assumed to be unique and
            // human-readable
            if (!id)
                return;

            // create anchor button
            const anchor = document.createElement('a');
            anchor.innerHTML = document.querySelector('.icon_link').innerHTML;
            anchor.title = 'Link to this part of the document';
            anchor.classList.add('icon_button', 'anchor');
            anchor.dataset.ignore = 'true';
            anchor.href = '#' + id;
            addTo.appendChild(anchor);
        }

        // get element that is target of link or url hash
        function getHashTarget() {
            const hash = window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');
            if (id.indexOf('tbl:') === 0)
                target = target.querySelector('table');

            return target;
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- link icon -->

<template class="icon_link">
    <!-- modified from: https://fontawesome.com/icons/link -->
    <svg width="16" height="16" viewBox="0 0 512 512">
        <path
            fill="currentColor"
            d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
        ></path>
    </svg>
</template>
<!-- accordion plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows sections of content under <h2> headings
        // to be collapsible.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'accordion';

        // default plugin options
        const options = {
            // whether to always start expanded ('false'), always start
            // collapsed ('true'), or start collapsed when screen small ('auto')
            startCollapsed: 'auto',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <h2> heading
            const headings = document.querySelectorAll('h2');
            for (const heading of headings) {
                addArrow(heading);

                // start expanded/collapsed based on option
                if (
                    options.startCollapsed === 'true' ||
                    (options.startCollapsed === 'auto' && isSmallScreen())
                )
                    collapseHeading(heading);
                else
                    expandHeading(heading);
            }

            // attach hash change listener to window
            window.addEventListener('hashchange', onHashChange);
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                goToElement(target);
        }

        // add arrow to heading
        function addArrow(heading) {
            // add arrow button
            const arrow = document.createElement('button');
            arrow.innerHTML = document.querySelector(
                '.icon_angle_down'
            ).innerHTML;
            arrow.classList.add('icon_button', 'accordion_arrow');
            heading.insertBefore(arrow, heading.firstChild);

            // attach click listener to heading and button
            heading.addEventListener('click', onHeadingClick);
            arrow.addEventListener('click', onArrowClick);
        }

        // determine if on mobile-like device with small screen
        function isSmallScreen() {
            return Math.min(window.innerWidth, window.innerHeight) < 480;
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get element that is target of hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if figure or table, modify target to get expected element
            if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');
            if (id.indexOf('tbl:') === 0)
                target = target.querySelector('table');

            return target;
        }

        // when <h2> heading is clicked
        function onHeadingClick(event) {
            // only collapse if <h2> itself is target of click (eg, user did
            // not click on anchor within <h2>)
            if (event.target === this)
                toggleCollapse(this);
        }

        // when arrow button is clicked
        function onArrowClick() {
            toggleCollapse(this.parentNode);
        }

        // collapse section if expanded, expand if collapsed
        function toggleCollapse(heading) {
            if (heading.dataset.collapsed === 'false')
                collapseHeading(heading);
            else
                expandHeading(heading);
        }

        // elements to exclude from collapse, such as table of contents panel,
        // hypothesis panel, etc
        const exclude = '#toc_panel, div.annotator-frame, #lightbox_overlay';

        // collapse section
        function collapseHeading(heading) {
            heading.setAttribute('data-collapsed', 'true');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'true');
        }

        // expand section
        function expandHeading(heading) {
            heading.setAttribute('data-collapsed', 'false');
            const children = getChildren(heading);
            for (const child of children)
                child.setAttribute('data-collapsed', 'false');
        }

        // get list of elements between this <h2> and next <h2> or <h1>
        // ("children" of the <h2> section)
        function getChildren(heading) {
            return nextUntil(heading, 'h2, h1', exclude);
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get list of elements after a start element up to element matching
        // query
        function nextUntil(element, query, exclude) {
            const elements = [];
            while (element = element.nextElementSibling, element) {
                if (element.matches(query))
                    break;
                if (!element.matches(exclude))
                    elements.push(element);
            }
            return elements;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle down icon -->

<template class="icon_angle_down">
    <!-- modified from: https://fontawesome.com/icons/angle-down -->
    <svg width="16" height="16" viewBox="0 0 448 512">
        <path
            fill="currentColor"
            d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"
        ></path>
    </svg>
</template>
<!-- tooltips plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when the user hovers or
        // focuses a link to a citation or figure, a tooltip appears with a
        // preview of the reference content, along with arrows to navigate
        // between instances of the same reference in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tooltips';

        // default plugin options
        const options = {
            // whether user must click off to close tooltip instead of just
            // un-hovering
            clickClose: 'false',
            // delay (in ms) between opening and closing tooltip
            delay: '100',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach hover and focus listeners to link
                link.addEventListener('mouseover', onLinkHover);
                link.addEventListener('mouseleave', onLinkUnhover);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('touchend', onLinkTouch);
            }

            // attach mouse, key, and resize listeners to window
            window.addEventListener('mousedown', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onResize);
        }

        // when link is hovered
        function onLinkHover() {
            // function to open tooltip
            const delayOpenTooltip = function() {
                openTooltip(this);
            }.bind(this);

            // run open function after delay
            this.openTooltipTimer = window.setTimeout(
                delayOpenTooltip,
                options.delay
            );
        }

        // when mouse leaves link
        function onLinkUnhover() {
            // cancel opening tooltip
            window.clearTimeout(this.openTooltipTimer);

            // don't close on unhover if option specifies
            if (options.clickClose === 'true')
                return;

            // function to close tooltip
            const delayCloseTooltip = function() {
                // if tooltip open and if mouse isn't over tooltip, close
                const tooltip = document.getElementById('tooltip');
                if (tooltip && !tooltip.matches(':hover'))
                    closeTooltip();
            };

            // run close function after delay
            this.closeTooltipTimer = window.setTimeout(
                delayCloseTooltip,
                options.delay
            );
        }

        // when link is focused (tabbed to)
        function onLinkFocus(event) {
            openTooltip(this);
        }

        // when link is touched on touch screen
        function onLinkTouch(event) {
            // attempt to force hover state on first tap always, and trigger
            // regular link click (and navigation) on second tap
            if (event.target === document.activeElement)
                event.target.click();
            else {
                document.activeElement.blur();
                event.target.focus();
            }
            if (event.cancelable)
                event.preventDefault();
            event.stopPropagation();
            return false;
        }

        // when mouse is clicked anywhere in window
        function onClick(event) {
            closeTooltip();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'tooltip_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'tooltip_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeTooltip();
                    break;
            }
        }

        // when window is resized or zoomed
        function onResize() {
            closeTooltip();
        }

        // get all links of types we wish to handle
        function getLinks() {
            const queries = [];
            // exclude buttons, anchor links, toc links, etc
            const exclude =
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            queries.push('a[href^="#ref-"]' + exclude); // citation links
            queries.push('a[href^="#fig:"]' + exclude); // figure links
            const query = queries.join(', ');
            return document.querySelectorAll(query);
        }

        // get links with same target, get index of link in set, get total
        // same links
        function getSameLinks(link) {
            const sameLinks = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    sameLinks.push(otherLink);
            }

            return {
                elements: sameLinks,
                index: sameLinks.indexOf(link),
                total: sameLinks.length
            };
        }

        // open tooltip
        function openTooltip(link) {
            // delete tooltip if it exists, start fresh
            closeTooltip();

            // make tooltip element
            const tooltip = makeTooltip(link);

            // if source couldn't be found and tooltip not made, exit
            if (!tooltip)
                return;

            // make navbar elements
            const navBar = makeNavBar(link);
            if (navBar)
                tooltip.firstElementChild.appendChild(navBar);

            // attach tooltip to page
            document.body.appendChild(tooltip);

            // position tooltip
            const position = function() {
                positionTooltip(link);
            };
            position();

            // if tooltip contains images, position again after they've loaded
            const imgs = tooltip.querySelectorAll('img');
            for (const img of imgs)
                img.addEventListener('load', position);
        }

        // close (delete) tooltip
        function closeTooltip() {
            const tooltip = document.getElementById('tooltip');
            if (tooltip)
                tooltip.remove();
        }

        // make tooltip
        function makeTooltip(link) {
            // get target element that link points to
            const source = getSource(link);

            // if source can't be found, exit
            if (!source)
                return;

            // create new tooltip
            const tooltip = document.createElement('div');
            tooltip.id = 'tooltip';
            const tooltipContent = document.createElement('div');
            tooltipContent.id = 'tooltip_content';
            tooltip.appendChild(tooltipContent);

            // make copy of source node and put in tooltip
            const sourceCopy = makeCopy(source);
            tooltipContent.appendChild(sourceCopy);

            // attach mouse event listeners
            tooltip.addEventListener('click', onTooltipClick);
            tooltip.addEventListener('mousedown', onTooltipClick);
            tooltip.addEventListener('touchstart', onTooltipClick);
            tooltip.addEventListener('mouseleave', onTooltipUnhover);

            // (for interaction with lightbox plugin)
            // transfer click on tooltip copied img to original img
            const sourceImg = source.querySelector('img');
            const sourceCopyImg = sourceCopy.querySelector('img');
            if (sourceImg && sourceCopyImg) {
                const clickImg = function() {
                    sourceImg.click();
                    closeTooltip();
                };
                sourceCopyImg.addEventListener('click', clickImg);
            }

            return tooltip;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // when tooltip is clicked
        function onTooltipClick(event) {
            // when user clicks on tooltip, stop click from transferring
            // outside of tooltip (eg, click off to close tooltip, or eg click
            // off to unhighlight same refs)
            event.stopPropagation();
        }

        // when tooltip is unhovered
        function onTooltipUnhover(event) {
            if (options.clickClose === 'true')
                return;

            // make sure new mouse/touch/focus no longer over tooltip or any
            // element within it
            const tooltip = document.getElementById('tooltip');
            if (!tooltip)
                return;
            if (this.contains(event.relatedTarget))
                return;

            closeTooltip();
        }

        // make nav bar to go betwen prev/next instances of same reference
        function makeNavBar(link) {
            // find other links to the same source
            const sameLinks = getSameLinks(link);

            // don't show nav bar when singular reference
            if (sameLinks.total <= 1)
                return;

            // find prev/next links with same target
            const prevLink = getPrevLink(link, sameLinks);
            const nextLink = getNextLink(link, sameLinks);

            // create nav bar
            const navBar = document.createElement('div');
            navBar.id = 'tooltip_nav_bar';
            const text = sameLinks.index + 1 + ' of ' + sameLinks.total;

            // create nav bar prev/next buttons
            const prevButton = document.createElement('button');
            const nextButton = document.createElement('button');
            prevButton.id = 'tooltip_prev_button';
            nextButton.id = 'tooltip_next_button';
            prevButton.title =
                'Jump to the previous occurence of this item in the document [←]';
            nextButton.title =
                'Jump to the next occurence of this item in the document [→]';
            prevButton.classList.add('icon_button');
            nextButton.classList.add('icon_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;
            navBar.appendChild(prevButton);
            navBar.appendChild(document.createTextNode(text));
            navBar.appendChild(nextButton);

            // attach click listeners to buttons
            prevButton.addEventListener('click', function() {
                onPrevNextClick(link, prevLink);
            });
            nextButton.addEventListener('click', function() {
                onPrevNextClick(link, nextLink);
            });

            return navBar;
        }

        // get previous link with same target
        function getPrevLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if < 1
            let index;
            if (sameLinks.index - 1 >= 0)
                index = sameLinks.index - 1;
            else
                index = sameLinks.total - 1;
            return sameLinks.elements[index];
        }

        // get next link with same target
        function getNextLink(link, sameLinks) {
            if (!sameLinks)
                sameLinks = getSameLinks(link);
            // wrap index to other side if > total
            let index;
            if (sameLinks.index + 1 <= sameLinks.total - 1)
                index = sameLinks.index + 1;
            else
                index = 0;
            return sameLinks.elements[index];
        }

        // get element that is target of link or url hash
        function getSource(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            // if ref or figure, modify target to get expected element
            if (id.indexOf('ref-') === 0)
                target = target.querySelector('p');
            else if (id.indexOf('fig:') === 0)
                target = target.querySelector('figure');

            return target;
        }

        // when prev/next arrow button is clicked
        function onPrevNextClick(link, prevNextLink) {
            if (link && prevNextLink)
                goToElement(prevNextLink, window.innerHeight * 0.5);
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // determine position to place tooltip based on link position in
        // viewport and tooltip size
        function positionTooltip(link, left, top) {
            const tooltipElement = document.getElementById('tooltip');
            if (!tooltipElement)
                return;

            // get convenient vars for position/dimensions of
            // link/tooltip/page/view
            link = getRectInPage(link);
            const tooltip = getRectInPage(tooltipElement);
            const view = getRectInPage();

            // horizontal positioning
            if (left)
                // use explicit value
                left = left;
            else if (link.left + tooltip.width < view.right)
                // fit tooltip to right of link
                left = link.left;
            else if (link.right - tooltip.width > view.left)
                // fit tooltip to left of link
                left = link.right - tooltip.width;
            // center tooltip in view
            else
                left = (view.right - view.left) / 2 - tooltip.width / 2;

            // vertical positioning
            if (top)
                // use explicit value
                top = top;
            else if (link.top - tooltip.height > view.top)
                // fit tooltip above link
                top = link.top - tooltip.height;
            else if (link.bottom + tooltip.height < view.bottom)
                // fit tooltip below link
                top = link.bottom;
            else {
                // center tooltip in view
                top = view.top + view.height / 2 - tooltip.height / 2;
                // nudge off of link to left/right if possible
                if (link.right + tooltip.width < view.right)
                    left = link.right;
                else if (link.left - tooltip.width > view.left)
                    left = link.left - tooltip.width;
            }

            tooltipElement.style.left = left + 'px';
            tooltipElement.style.top = top + 'px';
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get position of element relative to page
        function getRectInPage(element) {
            const rect = getRectInView(element);
            const body = getRectInView(document.body);

            const newRect = {};
            newRect.left = rect.left - body.left;
            newRect.top = rect.top - body.top;
            newRect.right = rect.right - body.left;
            newRect.bottom = rect.bottom - body.top;
            newRect.width = rect.width;
            newRect.height = rect.height;

            return newRect;
        }

        // (for interaction with accordion plugin)
        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // (for interaction with accordion plugin)
        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- jump to first plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin adds a button next to each reference entry,
        // figure, and table that jumps the page to the first occurrence of a
        // link to that item in the manuscript.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'jumpToFirst';

        // default plugin options
        const options = {
            // whether to add buttons next to reference entries
            references: 'true',
            // whether to add buttons next to figures
            figures: 'true',
            // whether to add buttons next to tables
            tables: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            if (options.references !== 'false')
                makeReferenceButtons();
            if (options.figures !== 'false')
                makeFigureButtons();
            if (options.tables !== 'false')
                makeTableButtons();
        }

        // when jump button clicked
        function onButtonClick() {
            const first = getFirstOccurrence(this.dataset.id);
            if (!first)
                return;

            // update url hash so navigating "back" in history will return
            // user to jump button
            window.location.hash = this.dataset.id;
            // scroll to link
            window.setTimeout(function() {
                goToElement(first, window.innerHeight * 0.5);
            }, 0);
        }

        // get first occurence of link to item in document
        function getFirstOccurrence(id) {
            let query = 'a';
            query += '[href="#' + id + '"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelector(query);
        }

        // add button next to each reference entry
        function makeReferenceButtons() {
            const references = document.querySelectorAll('div[id^="ref-"]');
            for (const reference of references) {
                // get reference id and element to add button to
                const id = reference.id;
                const container = reference.firstElementChild;
                const first = getFirstOccurrence(id);

                // if can't find link to reference, ignore
                if (!first)
                    continue;

                // make jump button
                let button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this reference in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.innerHTML = button.outerHTML + container.innerHTML;
                button = container.firstElementChild;
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeFigureButtons() {
            const figures = document.querySelectorAll('[id^="fig:"]');
            for (const figure of figures) {
                // get figure id and element to add button to
                const id = figure.id;
                const container = figure.querySelector('figcaption') || figure;
                const first = getFirstOccurrence(id);

                // if can't find link to figure, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this figure in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // add button next to each figure
        function makeTableButtons() {
            const tables = document.querySelectorAll('[id^="tbl:"]');
            for (const table of tables) {
                // get ref id and element to add button to
                const id = table.id;
                const container = table.querySelector('caption') || table;
                const first = getFirstOccurrence(id);

                // if can't find link to table, ignore
                if (!first)
                    continue;

                // make jump button
                const button = document.createElement('button');
                button.classList.add('icon_button', 'jump_arrow');
                button.title =
                    'Jump to the first occurence of this table in the document';
                button.innerHTML = document.querySelector(
                    '.icon_angle_double_up'
                ).innerHTML;
                button.dataset.id = id;
                button.dataset.ignore = 'true';
                container.insertBefore(button, container.firstElementChild);
                button.addEventListener('click', onButtonClick);
            }
        }

        // scroll to and focus element
        function goToElement(element, offset) {
            // expand accordion section if collapsed
            expandElement(element);
            const y =
                getRectInView(element).top -
                getRectInView(document.documentElement).top -
                (offset || 0);
            // trigger any function listening for "onscroll" event
            window.dispatchEvent(new Event('scroll'));
            window.scrollTo(0, y);
            document.activeElement.blur();
            element.focus();
        }

        // get position/dimensions of element or viewport
        function getRectInView(element) {
            let rect = {};
            rect.left = 0;
            rect.top = 0;
            rect.right = document.documentElement.clientWidth;
            rect.bottom = document.documentElement.clientHeight;
            let style = {};

            if (element instanceof HTMLElement) {
                rect = element.getBoundingClientRect();
                style = window.getComputedStyle(element);
            }

            const margin = {};
            margin.left = parseFloat(style.marginLeftWidth) || 0;
            margin.top = parseFloat(style.marginTopWidth) || 0;
            margin.right = parseFloat(style.marginRightWidth) || 0;
            margin.bottom = parseFloat(style.marginBottomWidth) || 0;

            const border = {};
            border.left = parseFloat(style.borderLeftWidth) || 0;
            border.top = parseFloat(style.borderTopWidth) || 0;
            border.right = parseFloat(style.borderRightWidth) || 0;
            border.bottom = parseFloat(style.borderBottomWidth) || 0;

            const newRect = {};
            newRect.left = rect.left + margin.left + border.left;
            newRect.top = rect.top + margin.top + border.top;
            newRect.right = rect.right + margin.right + border.right;
            newRect.bottom = rect.bottom + margin.bottom + border.bottom;
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        }

        // get closest element before specified element that matches query
        function firstBefore(element, query) {
            while (
                element &&
                element !== document.body &&
                !element.matches(query)
            )
                element = element.previousElementSibling || element.parentNode;

            return element;
        }

        // check if element is part of collapsed heading
        function isCollapsed(element) {
            while (element && element !== document.body) {
                if (element.dataset.collapsed === 'true')
                    return true;
                element = element.parentNode;
            }
            return false;
        }

        // (for interaction with accordion plugin)
        // expand heading containing element if necesary
        function expandElement(element) {
            if (isCollapsed(element)) {
                const heading = firstBefore(element, 'h2');
                if (heading)
                    heading.click();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- angle double up icon -->

<template class="icon_angle_double_up">
    <!-- modified from: https://fontawesome.com/icons/angle-double-up -->
    <svg width="16" height="16" viewBox="0 0 320 512">
        <path
            fill="currentColor"
            d="M177 255.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 351.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 425.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1zm-34-192L7 199.7c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l96.4-96.4 96.4 96.4c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9l-136-136c-9.2-9.4-24.4-9.4-33.8 0z"
        ></path>
    </svg>
</template>
<!-- link highlight plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user hovers or
        // focuses a link, other links that have the same target will be
        // highlighted. It also makes it such that when clicking a link, the
        // target of the link (eg reference, figure, table) is briefly
        // highlighted.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'linkHighlight';

        // default plugin options
        const options = {
            // whether to also highlight links that go to external urls
            externalLinks: 'false',
            // whether user must click off to unhighlight instead of just
            // un-hovering
            clickUnhighlight: 'false',
            // whether to also highlight links that are unique
            highlightUnique: 'true',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            const links = getLinks();
            for (const link of links) {
                // attach mouse and focus listeners to link
                link.addEventListener('mouseenter', onLinkFocus);
                link.addEventListener('focus', onLinkFocus);
                link.addEventListener('mouseleave', onLinkUnhover);
            }

            // attach click and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('hashchange', onHashChange);

            // run hash change on window load in case user has navigated
            // directly to hash
            onHashChange();
        }

        // when link is focused (tabbed to) or hovered
        function onLinkFocus() {
            highlight(this);
        }

        // when link is unhovered
        function onLinkUnhover() {
            if (options.clickUnhighlight !== 'true')
                unhighlightAll();
        }

        // when the mouse is clicked anywhere in window
        function onClick(event) {
            unhighlightAll();
        }

        // when hash (eg manuscript.html#introduction) changes
        function onHashChange() {
            const target = getHashTarget();
            if (target)
                glowElement(target);
        }

        // get element that is target of link or url hash
        function getHashTarget(link) {
            const hash = link ? link.hash : window.location.hash;
            const id = hash.slice(1);
            let target = document.querySelector('[id="' + id + '"]');
            if (!target)
                return;

            return target;
        }

        // start glow sequence on an element
        function glowElement(element) {
            const startGlow = function() {
                onGlowEnd();
                element.dataset.glow = 'true';
                element.addEventListener('animationend', onGlowEnd);
            };
            const onGlowEnd = function() {
                element.removeAttribute('data-glow');
                element.removeEventListener('animationend', onGlowEnd);
            };
            startGlow();
        }

        // highlight link and all others with same target
        function highlight(link) {
            // force unhighlight all to start fresh
            unhighlightAll();

            // get links with same target
            if (!link)
                return;
            const sameLinks = getSameLinks(link);

            // if link unique and option is off, exit and don't highlight
            if (sameLinks.length <= 1 && options.highlightUnique !== 'true')
                return;

            // highlight all same links, and "select" (special highlight) this
            // one
            for (const sameLink of sameLinks) {
                if (sameLink === link)
                    sameLink.setAttribute('data-selected', 'true');
                else
                    sameLink.setAttribute('data-highlighted', 'true');
            }
        }

        // unhighlight all links
        function unhighlightAll() {
            const links = getLinks();
            for (const link of links) {
                link.setAttribute('data-selected', 'false');
                link.setAttribute('data-highlighted', 'false');
            }
        }

        // get links with same target
        function getSameLinks(link) {
            const results = [];
            const links = getLinks();
            for (const otherLink of links) {
                if (
                    otherLink.getAttribute('href') === link.getAttribute('href')
                )
                    results.push(otherLink);
            }
            return results;
        }

        // get all links of types we wish to handle
        function getLinks() {
            let query = 'a';
            if (options.externalLinks !== 'true')
                query += '[href^="#"]';
            // exclude buttons, anchor links, toc links, etc
            query +=
                ':not(.button):not(.icon_button):not(.anchor):not(.toc_link)';
            return document.querySelectorAll(query);
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- table of contents plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin provides a "table of contents" (toc) panel on
        // the side of the document that allows the user to conveniently
        // navigate between sections of the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'tableOfContents';

        // default plugin options
        const options = {
            // which types of elements to add links for, in
            // "document.querySelector" format
            typesQuery: 'h1, h2, h3',
            // whether default behavior is to be closed ('false'), open
            // ('true'), or only open when screen wide enough to fit panel
            // ('auto'). note: still always starts closed when page loads.
            open: 'auto',
            // if list item is more than this many characters, text will be
            // truncated
            charLimit: '50',
            // whether or not to show bullets next to each toc item
            bullets: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // make toc panel and populate with entries (links to document
            // sections)
            const panel = makePanel();
            if (!panel)
                return;
            makeEntries(panel);
            document.body.insertBefore(panel, document.body.firstChild);

            closePanel();

            // attach click, scroll, and hash change listeners to window
            window.addEventListener('click', onClick);
            window.addEventListener('touchstart', onClick);
            window.addEventListener('scroll', onScroll);
            window.addEventListener('hashchange', onScroll);
            window.addEventListener('keyup', onKeyUp);
            onScroll();

            // add class to push document body down out of way of toc button
            document.body.classList.add('toc_body_nudge');
        }

        // determine if screen wide enough to fit toc panel
        function isSmallScreen() {
            // in default theme:
            // 816px = 8.5in = width of "page" (<body>) element
            // 260px = min width of toc panel (*2 for both sides of <body>)
            return window.innerWidth < 816 + 260 * 2;
        }

        // open/close panel based on option and screen size
        function openOrClosePanel() {
            if (
                options.open === 'true' ||
                (options.open === 'auto' && !isSmallScreen())
            )
                openPanel();
            else
                closePanel();
        }

        // when mouse is clicked anywhere in window
        function onClick() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                openOrClosePanel();
        }

        // when window is scrolled or hash changed
        function onScroll() {
            highlightViewed();
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            // close on esc
            if (event.key === 'Escape')
                closePanel();
        }

        // find entry of currently viewed document section in toc and highlight
        function highlightViewed() {
            const firstId = getFirstInView(options.typesQuery);

            // get toc entries (links), unhighlight all, then highlight viewed
            const list = document.getElementById('toc_list');
            if (!firstId || !list)
                return;
            const links = list.querySelectorAll('a');
            for (const link of links)
                link.dataset.viewing = 'false';
            const link = list.querySelector('a[href="#' + firstId + '"]');
            if (!link)
                return;
            link.dataset.viewing = 'true';
        }

        // get first or previous toc listed element in top half of view
        function getFirstInView(query) {
            // get all elements matching query and with id
            const elements = document.querySelectorAll(query);
            const elementsWithIds = [];
            for (const element of elements) {
                if (element.id)
                    elementsWithIds.push(element);
            }


            // get first or previous element in top half of view
            for (let i = 0; i < elementsWithIds.length; i++) {
                const element = elementsWithIds[i];
                const prevElement = elementsWithIds[Math.max(0, i - 1)];
                if (element.getBoundingClientRect().top >= 0) {
                    if (
                        element.getBoundingClientRect().top <
                        window.innerHeight / 2
                    )
                        return element.id;
                    else
                        return prevElement.id;
                }
            }
        }

        // make panel
        function makePanel() {
            // create panel
            const panel = document.createElement('div');
            panel.id = 'toc_panel';
            if (options.bullets === 'true')
                panel.dataset.bullets = 'true';

            // create header
            const header = document.createElement('div');
            header.id = 'toc_header';

            // create toc button
            const button = document.createElement('button');
            button.id = 'toc_button';
            button.innerHTML = document.querySelector('.icon_th_list').innerHTML;
            button.title = 'Table of Contents';
            button.classList.add('icon_button');

            // create header text
            const text = document.createElement('h3');
            text.innerHTML = 'View Table of Contents';

            // create container for toc list
            const list = document.createElement('div');
            list.id = 'toc_list';

            // attach click listeners
            panel.addEventListener('click', onPanelClick);
            header.addEventListener('click', onHeaderClick);
            button.addEventListener('click', onButtonClick);

            // attach elements
            header.appendChild(button);
            header.appendChild(text);
            panel.appendChild(header);
            panel.appendChild(list);

            return panel;
        }

        // create toc entries (links) to each element of the specified types
        function makeEntries(panel) {
            const elements = document.querySelectorAll(options.typesQuery);
            for (const element of elements) {
                // do not add link if element doesn't have assigned id
                if (!element.id)
                    continue;

                // create link/list item
                const link = document.createElement('a');
                link.classList.add('toc_link');
                switch (element.tagName.toLowerCase()) {
                    case 'h1':
                        link.dataset.level = '1';
                        break;
                    case 'h2':
                        link.dataset.level = '2';
                        break;
                    case 'h3':
                        link.dataset.level = '3';
                        break;
                    case 'h4':
                        link.dataset.level = '4';
                        break;
                }
                link.title = element.innerText;
                let text = element.innerText;
                if (text.length > options.charLimit)
                    text = text.slice(0, options.charLimit) + '...';
                link.innerHTML = text;
                link.href = '#' + element.id;
                link.addEventListener('click', onLinkClick);

                // attach link
                panel.querySelector('#toc_list').appendChild(link);
            }
        }

        // when panel is clicked
        function onPanelClick(event) {
            // stop click from propagating to window/document and closing panel
            event.stopPropagation();
        }

        // when header itself is clicked
        function onHeaderClick(event) {
            togglePanel();
        }

        // when button is clicked
        function onButtonClick(event) {
            togglePanel();
            // stop header underneath button from also being clicked
            event.stopPropagation();
        }

        // when link is clicked
        function onLinkClick() {
            openOrClosePanel();
        }

        // open panel if closed, close if opened
        function togglePanel() {
            const panel = document.getElementById('toc_panel');
            if (!panel)
                return;

            if (panel.dataset.open === 'true')
                closePanel();
            else
                openPanel();
        }

        // open panel
        function openPanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'true';
        }

        // close panel
        function closePanel() {
            const panel = document.getElementById('toc_panel');
            if (panel)
                panel.dataset.open = 'false';
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- th list icon -->

<template class="icon_th_list">
    <!-- modified from: https://fontawesome.com/icons/th-list -->
    <svg width="16" height="16" viewBox="0 0 512 512" tabindex="-1">
        <path
            fill="currentColor"
            d="M96 96c0 26.51-21.49 48-48 48S0 122.51 0 96s21.49-48 48-48 48 21.49 48 48zM48 208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm0 160c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm96-236h352c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h352c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H144c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
            tabindex="-1"
        ></path>
    </svg>
</template>
<!-- lightbox plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin makes it such that when a user clicks on an
        // image, the image fills the screen and the user can pan/drag/zoom
        // the image and navigate between other images in the document.

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'lightbox';

        // default plugin options
        const options = {
            // list of possible zoom/scale factors
            zoomSteps:
                '0.1, 0.25, 0.333333, 0.5, 0.666666, 0.75, 1,' +
                '1.25, 1.5, 1.75, 2, 2.5, 3, 3.5, 4, 5, 6, 7, 8',
            // whether to fit image to view ('fit'), display at 100% and shrink
            // if necessary ('shrink'), or always display at 100% ('100')
            defaultZoom: 'fit',
            // whether to zoom in/out toward center of view ('true') or mouse
            // ('false')
            centerZoom: 'false',
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // run through each <img> element
            const imgs = document.querySelectorAll('figure > img');
            let count = 1;
            for (const img of imgs) {
                img.classList.add('lightbox_document_img');
                img.dataset.number = count;
                img.dataset.total = imgs.length;
                img.addEventListener('click', openLightbox);
                count++;
            }

            // attach mouse and key listeners to window
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('keyup', onKeyUp);
        }

        // when mouse is moved anywhere in window
        function onWindowMouseMove(event) {
            window.mouseX = event.clientX;
            window.mouseY = event.clientY;
        }

        // when key pressed
        function onKeyUp(event) {
            if (!event || !event.key)
                return;

            switch (event.key) {
                // trigger click of prev button
                case 'ArrowLeft':
                    const prevButton = document.getElementById(
                        'lightbox_prev_button'
                    );
                    if (prevButton)
                        prevButton.click();
                    break;
                // trigger click of next button
                case 'ArrowRight':
                    const nextButton = document.getElementById(
                        'lightbox_next_button'
                    );
                    if (nextButton)
                        nextButton.click();
                    break;
                // close on esc
                case 'Escape':
                    closeLightbox();
                    break;
            }
        }

        // open lightbox
        function openLightbox() {
            const lightbox = makeLightbox(this);
            if (!lightbox)
                return;

            blurBody(lightbox);
            document.body.appendChild(lightbox);
        }

        // make lightbox
        function makeLightbox(img) {
            // delete lightbox if it exists, start fresh
            closeLightbox();

            // create screen overlay containing lightbox
            const overlay = document.createElement('div');
            overlay.id = 'lightbox_overlay';

            // create image info boxes
            const numberInfo = document.createElement('div');
            const zoomInfo = document.createElement('div');
            numberInfo.id = 'lightbox_number_info';
            zoomInfo.id = 'lightbox_zoom_info';

            // create container for image
            const imageContainer = document.createElement('div');
            imageContainer.id = 'lightbox_image_container';
            const lightboxImg = makeLightboxImg(
                img,
                imageContainer,
                numberInfo,
                zoomInfo
            );
            imageContainer.appendChild(lightboxImg);

            // create bottom container for caption and navigation buttons
            const bottomContainer = document.createElement('div');
            bottomContainer.id = 'lightbox_bottom_container';
            const caption = makeCaption(img);
            const prevButton = makePrevButton(img);
            const nextButton = makeNextButton(img);
            bottomContainer.appendChild(prevButton);
            bottomContainer.appendChild(caption);
            bottomContainer.appendChild(nextButton);

            // attach top middle and bottom to overlay
            overlay.appendChild(numberInfo);
            overlay.appendChild(zoomInfo);
            overlay.appendChild(imageContainer);
            overlay.appendChild(bottomContainer);

            return overlay;
        }

        // make <img> object that is intuitively draggable and zoomable
        function makeLightboxImg(
            sourceImg,
            container,
            numberInfoBox,
            zoomInfoBox
        ) {
            // create copy of source <img>
            const img = sourceImg.cloneNode(true);
            img.classList.remove('lightbox_document_img');
            img.removeAttribute('id');
            img.removeAttribute('width');
            img.removeAttribute('height');
            img.style.position = 'unset';
            img.style.margin = '0';
            img.style.padding = '0';
            img.style.width = '';
            img.style.height = '';
            img.style.minWidth = '';
            img.style.minHeight = '';
            img.style.maxWidth = '';
            img.style.maxHeight = '';
            img.id = 'lightbox_img';

            // build sorted list of unique zoomSteps, always including a 100%
            let zoomSteps = [];
            const optionsZooms = options.zoomSteps.split(/[^0-9.]/);
            for (const optionZoom of optionsZooms) {
                const newZoom = parseFloat(optionZoom);
                if (newZoom && !zoomSteps.includes(newZoom))
                    zoomSteps.push(newZoom);
            }
            if (!zoomSteps.includes(1))
                zoomSteps.push(1);
            zoomSteps = zoomSteps.sort(function sortNumber(a, b) {
                return a - b;
            });

            // <img> object property variables
            let zoom = 1;
            let translateX = 0;
            let translateY = 0;
            let clickMouseX = undefined;
            let clickMouseY = undefined;
            let clickTranslateX = undefined;
            let clickTranslateY = undefined;

            updateNumberInfo();

            // update image numbers displayed in info box
            function updateNumberInfo() {
                numberInfoBox.innerHTML =
                    sourceImg.dataset.number + ' of ' + sourceImg.dataset.total;
            }

            // update zoom displayed in info box
            function updateZoomInfo() {
                let zoomInfo = zoom * 100;
                if (!Number.isInteger(zoomInfo))
                    zoomInfo = zoomInfo.toFixed(2);
                zoomInfoBox.innerHTML = zoomInfo + '%';
            }

            // move to closest zoom step above current zoom
            const zoomIn = function() {
                for (const zoomStep of zoomSteps) {
                    if (zoomStep > zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                updateTransform();
            };

            // move to closest zoom step above current zoom
            const zoomOut = function() {
                zoomSteps.reverse();
                for (const zoomStep of zoomSteps) {
                    if (zoomStep < zoom) {
                        zoom = zoomStep;
                        break;
                    }
                }
                zoomSteps.reverse();

                updateTransform();
            };

            // update display of <img> based on scale/translate properties
            const updateTransform = function() {
                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                // get new width/height after scale
                const rect = img.getBoundingClientRect();
                // limit translate
                translateX = Math.max(translateX, -rect.width / 2);
                translateX = Math.min(translateX, rect.width / 2);
                translateY = Math.max(translateY, -rect.height / 2);
                translateY = Math.min(translateY, rect.height / 2);

                // set transform
                img.style.transform =
                    'translate(' +
                    (translateX || 0) +
                    'px,' +
                    (translateY || 0) +
                    'px) scale(' +
                    (zoom || 1) +
                    ')';

                updateZoomInfo();
            };

            // fit <img> to container
            const fit = function() {
                // no x/y offset, 100% zoom by default
                translateX = 0;
                translateY = 0;
                zoom = 1;

                // widths of <img> and container
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const containerWidth = parseFloat(
                    window.getComputedStyle(container).width
                );
                const containerHeight = parseFloat(
                    window.getComputedStyle(container).height
                );

                // how much zooming is needed to fit <img> to container
                const xRatio = imgWidth / containerWidth;
                const yRatio = imgHeight / containerHeight;
                const maxRatio = Math.max(xRatio, yRatio);
                const newZoom = 1 / maxRatio;

                // fit <img> to container according to option
                if (options.defaultZoom === 'shrink') {
                    if (maxRatio > 1)
                        zoom = newZoom;
                } else if (options.defaultZoom === 'fit')
                    zoom = newZoom;

                updateTransform();
            };

            // when mouse wheel is rolled anywhere in container
            const onContainerWheel = function(event) {
                if (!event)
                    return;

                // let ctrl + mouse wheel to zoom behave as normal
                if (event.ctrlKey)
                    return;

                // prevent normal scroll behavior
                event.preventDefault();
                event.stopPropagation();

                // point around which to scale img
                const viewRect = container.getBoundingClientRect();
                const viewX = (viewRect.left + viewRect.right) / 2;
                const viewY = (viewRect.top + viewRect.bottom) / 2;
                const originX = options.centerZoom === 'true' ? viewX : mouseX;
                const originY = options.centerZoom === 'true' ? viewY : mouseY;

                // get point on image under origin
                const oldRect = img.getBoundingClientRect();
                const oldPercentX = (originX - oldRect.left) / oldRect.width;
                const oldPercentY = (originY - oldRect.top) / oldRect.height;

                // increment/decrement zoom
                if (event.deltaY < 0)
                    zoomIn();
                if (event.deltaY > 0)
                    zoomOut();

                // get offset between previous image point and origin
                const newRect = img.getBoundingClientRect();
                const offsetX =
                    originX - (newRect.left + newRect.width * oldPercentX);
                const offsetY =
                    originY - (newRect.top + newRect.height * oldPercentY);

                // translate image to keep image point under origin
                translateX += offsetX;
                translateY += offsetY;

                // perform translate
                updateTransform();
            };

            // when container is clicked
            function onContainerClick(event) {
                // if container itself is target of click, and not other
                // element above it
                if (event.target === this)
                    closeLightbox();
            }

            // when mouse button is pressed on image
            const onImageMouseDown = function(event) {
                // store original mouse position relative to image
                clickMouseX = window.mouseX;
                clickMouseY = window.mouseY;
                clickTranslateX = translateX;
                clickTranslateY = translateY;
                event.stopPropagation();
                event.preventDefault();
            };

            // when mouse button is released anywhere in window
            const onWindowMouseUp = function(event) {
                // reset original mouse position
                clickMouseX = undefined;
                clickMouseY = undefined;
                clickTranslateX = undefined;
                clickTranslateY = undefined;

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mouseup', onWindowMouseUp);
            };

            // when mouse is moved anywhere in window
            const onWindowMouseMove = function(event) {
                if (
                    clickMouseX === undefined ||
                    clickMouseY === undefined ||
                    clickTranslateX === undefined ||
                    clickTranslateY === undefined
                )
                    return;

                // offset image based on original and current mouse position
                translateX = clickTranslateX + window.mouseX - clickMouseX;
                translateY = clickTranslateY + window.mouseY - clickMouseY;
                updateTransform();
                event.preventDefault();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('mousemove', onWindowMouseMove);
            };

            // when window is resized
            const onWindowResize = function(event) {
                fit();

                // remove global listener if lightbox removed from document
                if (!document.body.contains(container))
                    window.removeEventListener('resize', onWindowResize);
            };

            // attach the necessary event listeners
            img.addEventListener('dblclick', fit);
            img.addEventListener('mousedown', onImageMouseDown);
            container.addEventListener('wheel', onContainerWheel);
            container.addEventListener('mousedown', onContainerClick);
            container.addEventListener('touchstart', onContainerClick);
            window.addEventListener('mouseup', onWindowMouseUp);
            window.addEventListener('mousemove', onWindowMouseMove);
            window.addEventListener('resize', onWindowResize);

            // run fit() after lightbox atttached to document and <img> Loaded
            // so needed container and img dimensions available
            img.addEventListener('load', fit);

            return img;
        }

        // make caption
        function makeCaption(img) {
            const caption = document.createElement('div');
            caption.id = 'lightbox_caption';
            const captionSource = img.nextElementSibling;
            if (captionSource.tagName.toLowerCase() === 'figcaption') {
                const captionCopy = makeCopy(captionSource);
                caption.innerHTML = captionCopy.innerHTML;
            }

            caption.addEventListener('touchstart', function(event) {
                event.stopPropagation();
            });

            return caption;
        }

        // make carbon copy of html dom element
        function makeCopy(source) {
            const sourceCopy = source.cloneNode(true);

            // delete elements marked with ignore (eg anchor and jump buttons)
            const deleteFromCopy = sourceCopy.querySelectorAll(
                '[data-ignore="true"]'
            );
            for (const element of deleteFromCopy)
                element.remove();

            // delete certain element attributes
            const attributes = [
                'id',
                'data-collapsed',
                'data-selected',
                'data-highlighted',
                'data-glow'
            ];
            for (const attribute of attributes) {
                sourceCopy.removeAttribute(attribute);
                const elements = sourceCopy.querySelectorAll(
                    '[' + attribute + ']'
                );
                for (const element of elements)
                    element.removeAttribute(attribute);
            }

            return sourceCopy;
        }

        // make button to jump to previous image in document
        function makePrevButton(img) {
            const prevButton = document.createElement('button');
            prevButton.id = 'lightbox_prev_button';
            prevButton.title = 'Jump to the previous image in the document [←]';
            prevButton.classList.add('icon_button', 'lightbox_button');
            prevButton.innerHTML = document.querySelector(
                '.icon_caret_left'
            ).innerHTML;

            // attach click listeners to button
            prevButton.addEventListener('click', function() {
                getPrevImg(img).click();
            });

            return prevButton;
        }

        // make button to jump to next image in document
        function makeNextButton(img) {
            const nextButton = document.createElement('button');
            nextButton.id = 'lightbox_next_button';
            nextButton.title = 'Jump to the next image in the document [→]';
            nextButton.classList.add('icon_button', 'lightbox_button');
            nextButton.innerHTML = document.querySelector(
                '.icon_caret_right'
            ).innerHTML;

            // attach click listeners to button
            nextButton.addEventListener('click', function() {
                getNextImg(img).click();
            });

            return nextButton;
        }

        // get previous image in document
        function getPrevImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if < 1
            if (index - 1 >= 0)
                index--;
            else
                index = imgs.length - 1;
            return imgs[index];
        }

        // get next image in document
        function getNextImg(img) {
            const imgs = document.querySelectorAll('.lightbox_document_img');

            // find index of provided img
            let index;
            for (index = 0; index < imgs.length; index++) {
                if (imgs[index] === img)
                    break;
            }


            // wrap index to other side if > total
            if (index + 1 <= imgs.length - 1)
                index++;
            else
                index = 0;
            return imgs[index];
        }

        // close lightbox
        function closeLightbox() {
            focusBody();

            const lightbox = document.getElementById('lightbox_overlay');
            if (lightbox)
                lightbox.remove();
        }

        // make all elements behind lightbox non-focusable
        function blurBody(overlay) {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.tabIndex = -1;
            document.body.classList.add('body_no_scroll');
        }

        // make all elements focusable again
        function focusBody() {
            const all = document.querySelectorAll('*');
            for (const element of all)
                element.removeAttribute('tabIndex');
            document.body.classList.remove('body_no_scroll');
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>

<!-- caret left icon -->

<template class="icon_caret_left">
    <!-- modified from: https://fontawesome.com/icons/caret-left -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M192 127.338v257.324c0 17.818-21.543 26.741-34.142 14.142L29.196 270.142c-7.81-7.81-7.81-20.474 0-28.284l128.662-128.662c12.599-12.6 34.142-3.676 34.142 14.142z"
        ></path>
    </svg>
</template>

<!-- caret right icon -->

<template class="icon_caret_right">
    <!-- modified from: https://fontawesome.com/icons/caret-right -->
    <svg width="16" height="16" viewBox="0 0 192 512">
        <path
            fill="currentColor"
            d="M0 384.662V127.338c0-17.818 21.543-26.741 34.142-14.142l128.662 128.662c7.81 7.81 7.81 20.474 0 28.284L34.142 398.804C21.543 411.404 0 402.48 0 384.662z"
        ></path>
    </svg>
</template>
<!-- attributes plugin -->

<script>
    (function() {
        // /////////////////////////
        // DESCRIPTION
        // /////////////////////////

        // This Manubot plugin allows arbitrary HTML attributes to be attached
        // to (almost) any element. Place an HTML comment inside or next to the
        // desired element in the format <!-- $attribute="value" -->

        // /////////////////////////
        // OPTIONS
        // /////////////////////////

        // plugin name prefix for url parameters
        const pluginName = 'attributes';

        // default plugin options
        const options = {
            // whether plugin is on or not
            enabled: 'true'
        };

        // change options above, or override with url parameter, eg:
        // 'manuscript.html?pluginName-enabled=false'

        // /////////////////////////
        // SCRIPT
        // /////////////////////////

        // start script
        function start() {
            // get list of comments in document
            const comments = findComments();

            for(const comment of comments)
                if (comment.parentElement)
                    addAttributes(
                        comment.parentElement,
                        comment.nodeValue.trim()
                    );
        }

        // add html attributes to specified element based on string of 
        // html attributes and values
        function addAttributes(element, text) {
            // regex's for finding attribute/value pairs in the format of
            // attribute="value" or attribute='value
            const regex2 = /\$([a-zA-Z\-]+)?=\"(.+?)\"/;
            const regex1 = /\$([a-zA-Z\-]+)?=\'(.+?)\'/;

            // loop through attribute/value pairs
            let match;
            while(match = text.match(regex2) || text.match(regex1)) {
                // get attribute and value from regex capture groups
                let attribute = match[1];
                let value = match[2];

                // remove from string
                text = text.substring(match.index + match[0].length);

                if (!attribute || !value)
                    break;

                // set attribute of parent element
                try {
                    element.setAttribute(attribute, value);
                } catch(error) {
                    console.log(error);
                }

                // special case for colspan
                if (attribute === 'colspan')
                    removeTableCells(element, value);
            }
        }

        // get list of comment elements in document
        function findComments() {
            const comments = [];

            // iterate over comment nodes in document
            function acceptNode(node) {
                return NodeFilter.FILTER_ACCEPT;
            }
            const iterator = document.createNodeIterator(
                document.body,
                NodeFilter.SHOW_COMMENT,
                acceptNode
            );
            let node;
            while(node = iterator.nextNode())
                comments.push(node);

            return comments;
        }

        // remove certain number of cells after specified cell
        function removeTableCells(cell, number) {
            number = parseInt(number);
            if (!number)
                return;

            // remove elements
            for(; number > 1; number--) {
                if (cell.nextElementSibling)
                    cell.nextElementSibling.remove();
            }
        }

        // load options from url parameters
        function loadOptions() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            for (const optionName of Object.keys(options)) {
                const paramName = pluginName + '-' + optionName;
                const param = params.get(paramName);
                if (param !== '' && param !== null)
                    options[optionName] = param;
            }
        }
        loadOptions();

        // start script when document is finished loading
        if (options.enabled === 'true')
            window.addEventListener('load', start);
    })();
</script>
<!-- math plugin configuration -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "CommonHTML": { linebreaks: { automatic: true } },
        "HTML-CSS": { linebreaks: { automatic: true } },
        "SVG": { linebreaks: { automatic: true } },
        "fast-preview": { disabled: true }
    });
</script>

<!-- math plugin -->

<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'MathJax' allows the proper rendering of
    // math/equations written in LaTeX.

    // https://www.mathjax.org/
</script>
<!-- annotations plugin -->

<script>
    // /////////////////////////
    // DESCRIPTION
    // /////////////////////////

    // This third-party plugin 'Hypothesis' allows public annotation of the
    // manuscript.

    // https://web.hypothes.is/

    // plugin configuration
    window.hypothesisConfig = function() {
        return {
            branding: {
                accentColor: '#2196f3',
                appBackgroundColor: '#f8f8f8',
                ctaBackgroundColor: '#f8f8f8',
                ctaTextColor: '#000000',
                selectionFontFamily: 'Open Sans, Helvetica, sans serif',
                annotationFontFamily: 'Open Sans, Helvetica, sans serif'
            }
        };
    };

    // hypothesis client script
    const embed = 'https://hypothes.is/embed.js';
    // hypothesis annotation count query url
    const query = 'https://api.hypothes.is/api/search?limit=0&url='

    
    // start script
    function start() {
        const button = makeButton();
        document.body.insertBefore(button, document.body.firstChild);
        insertCount(button);
    }

    // make button
    function makeButton() {
        // create button
        const button = document.createElement('button');
        button.id = 'hypothesis_button';
        button.innerHTML = document.querySelector('.icon_hypothesis').innerHTML;
        button.title = 'Hypothesis annotations';
        button.classList.add('icon_button');

        function onClick(event) {
            onButtonClick(event, button);
        }

        // attach click listeners
        button.addEventListener('click', onClick);

        return button;
    }

    // insert annotations count
    async function insertCount(button) {
        // get annotation count from Hypothesis based on url
        let count = '-';
        try {
            const canonical = document.querySelector('link[rel="canonical"]');
            const location = window.location;
            const url = encodeURIComponent((canonical || location).href);
            const response = await fetch(query + url);
            const json = await response.json();
            count = json.total || '-';
        } catch(error) {
            console.log(error);
        }
        
        // put count into button
        const counter = document.createElement('span');
        counter.id = 'hypothesis_count';
        counter.innerHTML = count;
        button.title = 'View ' + count + ' Hypothesis annotations';
        button.append(counter);
    }

    // when button is clicked
    function onButtonClick(event, button) {
        const script = document.createElement('script');
        script.src = embed;
        document.body.append(script);
        button.remove();
    }

    window.addEventListener('load', start);
</script>

<!-- hypothesis icon -->

<template class="icon_hypothesis">
    <!-- modified from: https://simpleicons.org/icons/hypothesis.svg / https://git.io/Jf1VB -->
    <svg width="16" height="16" viewBox="0 0 24 24" tabindex="-1">
        <path
            fill="currentColor"
            d="M3.43 0C2.5 0 1.72 .768 1.72 1.72V18.86C1.72 19.8 2.5 20.57 3.43 20.57H9.38L12 24L14.62 20.57H20.57C21.5 20.57 22.29 19.8 22.29 18.86V1.72C22.29 .77 21.5 0 20.57 0H3.43M5.14 3.43H7.72V9.43S8.58 7.72 10.28 7.72C12 7.72 13.74 8.57 13.74 11.24V17.14H11.16V12C11.16 10.61 10.28 10.07 9.43 10.29C8.57 10.5 7.72 11.41 7.72 13.29V17.14H5.14V3.43M18 13.72C18.95 13.72 19.72 14.5 19.72 15.42A1.71 1.71 0 0 1 18 17.13A1.71 1.71 0 0 1 16.29 15.42C16.29 14.5 17.05 13.71 18 13.71Z"
            tabindex="-1"
        ></path>
    </svg>
</template>
<!-- analytics plugin -->

<!-- copy and paste code from Google Analytics or similar service here -->
</body>
</html>
