# Methods

## Implementation of FracMinHash and min-set-cov

We provide implementations of FracMinHash and min-set-cov in the
software package `sourmash`, which is implemented in Python and Rust
and developed under the BSD license [@doi:10.21105/joss.00027] (cite
joss, zenodo latest version, github URL). FracMinHash sketches are
created for DNA sequence inputs using the `sourmash sketch dna`
command with the `scaled` parameter. Minimum metagenome covers are
generated using `sourmash gather` with the sketched metagenome as
query against a collection of one or more sketched genomes.

## Comparison between CMash, mash screen, and Scaled MinHash.

Experiments use $k=\{21, 31, 51\}$ (except for Mash, which only
supports $k \le 32$).  For Mash and CMash they were run with
$n=\{1000, 10000\}$ to evaluate the containment estimates when using
larger sketches with sizes comparable to the FracMinHash sketches
with $scaled=1000$.  The truth set is calculated using an exact
$k$-mer counter implemented with a _HashSet_ data structure in the
Rust programming language [@matsakis_rust_2014].

For _Mash Screen_ the ratio of hashes matched by total hashes is used
instead of the _Containment Score_, since the latter uses a $k$-mer
survival process modeled as a Poisson process first introduced in
[@fan_assembly_2015] and later used in the _Mash distance_
[@ondov_mash:_2016] and _Containment score_ [@ondov_mash_2019]
formulations.

## GenBank database sketching and searches

Minimum metagenome covers were calculated using a microbial genome
subset of GenBank (date XYZ, number of genomes ZZZ) using a scaled
factor of 2000 and a k-mer size of 31. Sketches for all genomes and
metagenomes were calculated with `sourmash sketch dna -p
scaled=2000,k=31`. The minimum metagenome covers were calculated using
all genomes sharing 100 hashes with the metagenome (that is, an
estimated overlap of 100,000 k-mers) with
`sourmash gather --threshold-bp 1e5`.
Overlapping sketches were saved with `--save-prefetch`
and matches were saved with `--save-matches`.

The GenBank database used is XYZ GB in size and is available for download
at ZZZ.

## Taxonomy

(I guess say what Luiz used, and then repeat this using sourmash taxonomy.)

## Read mapping and hybrid mapping pipeline

Metagenome reads were mapped to reference genomes using minimap2 v2.17 (cite)
with `-x sr` (short single-end read mapping mode). 

The complete workflow, from metagenome download to taxonomic analysis
and iterative mapping, is implemented in the genome-grist package
(version, doi, etc.). genome-grist uses snakemake (cite) to implement
a workflow that combines sourmash sketching, metagenome cover
calculation, and taxonomic analysis with metagenome download from the
SRA, genome download from GenBank, and read mapping.

The hybrid selection and mapping pipeline using the rank-ordered min-set-cov
results was implemented in the `subtract_gather.py` script that is part
of the genome-grist package.

## Figures and notebooks for this paper.

(point at gather figures repo)

## Data accessions

The summary results from genome-grist for this paper are available HERE.

## Revised theoretical analysis of FracMinHash

Given two arbitrary sets $A$ and $B$ which are subsets of a domain
$\Omega$, the containment index $C(A,B)$ is defined as
$C(A,B):=\frac{\vert A \cap B \vert}{\vert A \vert}$. Let $h$ be a
perfect hash function $h~:~\Omega \rightarrow~[0,H]$ for some $H\in
\mathbb{R}$. For a *scale factor* $s$ where $0 \le s \le 1$, a
FracMinHash sketch of a set $A$ is defined as follows:

{% raw %}
```{=latex}
\begin{equation}
    %\mathbf{FRAC}_S(A) = \left\{\,h(a) \mid \forall a \in A\ {\rm s.t.}\ h(a) \leq Hs\right\}.
    \mathbf{FRAC}_S(A) = \left\{\,h(a) \mid \forall a \in A\ {\rm s.t.}\ h(a) \leq Hs\right\}.
\end{equation}
```
{% endraw %}

The scale factor $s$ is a tunable parameter that can modify the size of the sketch. Using this FracMinHash sketch, we define the FracMinHash estimate of the containment index $\hat{C}_\text{frac}(A,B)$ as follows:

{% raw %}
```{=latex}
\begin{equation}
    \hat{C}_\text{scale}(A,B):=\frac{\vert \mathbf{FRAC}_S(A) \cap \mathbf{FRAC}_S(B)\vert }{\vert \mathbf{FRAC}_S(A)\vert}.
\end{equation}
```
{% endraw %}

For notational simplicity, we define $X_A := \vert \mathbf{FRAC}_S(A)
\vert$. Observe that if one views $h$ as a uniformly distributed
random variable, we have that $X_A$ is distributed as a binomial
random variable: $X_A \sim {\rm Binom}(|A|, s)$. Furthermore, if
$A\cap B = \emptyset$ where both $A$ and $B$ are non-empty sets, then
$X_A$ and $X_B$ are independent when the probability of success is
strictly smaller than $1$. Using these notations, we compute the
expectation of (equation).


For $0<s<1$, if $A$ and $B$ are two distinct sets such that $A \cap B$ is non-empty,
{% raw %}
```{=latex}
\begin{align}
\E\left[\hat{C}_\text{frac}(A,B) \mathbbm{1}_{\vert \mathbf{FRAC}_S(A) \vert>0} \right] =
\frac{\vert A\cap B \vert}{\vert A \vert} \left(1-(1-s)^{\vert A\vert}\right).
\end{align}
```
{% endraw %}


Using the notation introduced previously, observe that 

{% raw %}
```{=latex}
\begin{align}
\hat{C}_\text{frac}(A,B) \mathbbm{1}_{\vert \mathbf{FRAC}_S(A) \vert>0} = \frac{X_{A\cap B}}{X_{A\cap B} + X_{A\setminus B}} \mathbbm{1}_{X_{A\cap B} + X_{A\setminus B}>0},
\end{align}
```
{% endraw %}

and that the random variables $X_{A\cap B}$ and $X_{A\setminus B}$ are independent (which follows directly from the fact that $A \cap B$ is non-empty, and because $A$ and $B$ are distinct, $A \setminus B$ is also non-empty).
We will use the following fact from standard calculus:

{% raw %}
```{=latex}
\begin{align}
    \int_0^1 x t^{x+y-1}\, dt = \frac{x}{x+y} \unicode{x1D7D9}_{x+y>0}.
\end{align}
```
{% endraw %}

Then using the moment generating function of the binomial distribution, we have

{% raw %}
```{=latex}
\begin{align}
    \mathrm{E}\left[t^X_{A\cap B}\right] &= (1-s+st)^{\vert A \cap B \vert}\\
    \mathrm{E}\left[t^X_{A\setminus B}\right] &= (1-s+st)^{\vert A \setminus B \vert}
\end{align}
```
{% endraw %}

We also know by continuity that 
{% raw %}
```{=latex}
\begin{align}
    \mathrm{E}\left[X_{A\cap B} \, t^{X_{A\cap B}-1}\right] &= \frac{d}{dt} (1-s+st)^{\vert A \cap B \vert}\\
    &= \vert A\cap B \vert s (1-s+st)^{\vert A\cap B\vert-1}.
\end{align}
```
{% endraw %}

Using these observations, we can then finally calculate that 


{% raw %}
```{=latex}
\begin{align}
    \mathrm{E}\left[\frac{X_{A\cap B}}{X_{A\cap B} + X_{A\setminus B}} \mathbbm{1}_{X_{A\cap B} + X_{A\setminus B}>0},\right] &= \mathrm{E}\left[\int_0^1 X_{A\cap B} \,  t^{X_{A\cap B}+X_{A\setminus B}-1}\,dt\right]\\
    &= \int_0^1 \mathrm{E}\left[X_{A\cap B}  \, t^{X_{A\cap B}+X_{A\setminus B}-1}\,dt\right]\label{line:1}\\
    &= \int_0^1 \mathrm{E}\left[X_{A\cap B}  \, t^{X_{A\cap B}-1}\right] \mathrm{E}\left[t^X_{A\setminus B}\right]\,dt\label{line:2}\\
    &= \vert A\cap B\vert \int_0^1(1-s+st)^{\vert A\cap B \vert + \vert A\setminus B \vert -1}\, dt\\
    &= \frac{\vert A \cap B\vert (1-s+st)^{\vert A \vert}}{\vert A \vert}\bigg\rvert_{t=0}^{t=1}\\
    &= \frac{\vert A\cap B \vert}{\vert A \vert} \left(1-(1-s)^{\vert A\vert}\right),
\end{align}
```
{% endraw %}

where Fubini's theorem is used in (line 1) and independence in (line 2).


In light of (theorem), we note that (eqution) is *not* an
unbiased estimate of $C(A,B)$. This may explain the observations in
(Luiz thesis) that showed the uncorrected version in (eqn) leads to
suboptimal performance for short sequences (e.g viruses). However, for
sufficiently large $\vert A \vert$ and $s$, the bias factor
$\left(1-(1-s)^{\vert A\vert}\right)$ is sufficiently close to 1.

The expectation of $C_\text{frac}(A,B)$ follows directly from
(equation) and (theorem): for $0<s<1$, if $A$ and $B$ are two distinct
sets such that $A \cap B$ is non-empty, the expectation of $C_\text{frac}(A, B)$ is
given by

$$
\mathrm{E} [C_\text{frac}(A,B)] = \frac{\vert A\cap B \vert}{\vert A \vert}
$$
